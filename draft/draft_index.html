<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>나의 블록체인 블로그</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <header>
        <h1>나의 블록체인 블로그</h1>
        <p style="color: #ff4d94; font-size: 24px; text-align: center" ;>블록체인 부트캠프 일지</p>


        <div class="container">
            <div class="container"></div>
            <div class="item">홈</div>
            <div class="item">소개</div>
            <div class="item">블로그</div>
            <div class="item">문의</div>
        </div>
    </header>

    <main>
        <section id="home">
            <h2>안녕하세요.</h2>
            <p>
                이 곳은 블록체인 꿈나무 윤정아의 블로그입니다. 반갑습니다.
            </p>
        </section>

        <section id="about">
            <h2>소개</h2>
            <p>저는 블록체인 엔지니어 부트캠프에 참여하고 있고, 부트캠프에서의 일지를 시작으로 블록체인에 대한 다양한 이야기를 나누려 합니다.</p>
        </section>

        <section id="blog">
            <h2>최신 글</h2>
            <article>
                <h3>비트코인의 탄생 배경</h3>
                <p>
                    2025년 2월 3일 <br>

                <h4>블록체인이란?</h4>
                데이터가 해시값으로 블록에 기록되어 있고 블록들이 시간 순서대로 연결되어 있는 것.
                <br>
                <h4>블록체인이 만들어진 배경은?</h4>
                89년, 한 연구자의 연구 결과가 조작된 것이라는 스캔들을 본 과학자 스콧 스토네타가 디지털 기록의 중요성을 절감했고, 암호학자인 스튜어트 하버와 함께 디지털 기록의 불변성에 대한 공동
                연구를 해 만들었다. 그들이 만든 블록체인의 기본 메커니즘은 데이터 전체가 아닌 해시값만 전송해서 타임스탬프를 부여받고 이를 디지털 서명으로 보증받는다는 것이었다.

                <h4>비트코인은 화폐일까?</h4>
                다음 화폐 3대 요소를 갖추고 있는지를 기준으로 살펴보자.
                <ol>
                    <li>교환의 매개체: 아직 대부분의 사람들은 실생활에서 비트코인을 사용해 교환/거래 하지 않는다.</li>
                    <li>가치 척도의 기능: 스테이블 코인의 등장으로 가치 척도가 어느정도 가능해졌지만 여전히 높은 가격 변동성으로 인해 가치 척도의 기능을 온전히 해내기 어렵다.</li>
                    <li>가치 저장의 기능: 비트코인이 이 기능은 현재 가지고 있다. 이미 일부 국가에서는 법정화폐를 대신해 사용되기 시작했다.</li>
                </ol>
                여기서 블록체인 엔지니어로서 고민할 부분을 찾을 수 있다.
                <ul>
                    <li>마트에서 비트코인으로 계산하기 어려운데 사용성을 향상할 방법은?</li>
                    <li>가치 척도의 기능으로서의 한계를 극복할 방법은?</li>
                </ul>
                <h4>새 기술은 문제 해결을 위해 태어난다. 비트코인은 어떤 문제 해결을 위해 태어났을까?</h4>
                2000년대 IT 버블 붕괴, 아프간/이라크 전쟁 등으로 미국 경기가 약화되지 미국은 초 저금리 정책을 펼쳐 대응한다. 부동산 가격이 상승하기 시작했고 금융사는 신용 등급이 낮은
                사람에게도 주택 담보 대출을 해주기 시작했다. 2004년, 미국 경제가 회복세에 들어가면서 초 저금리 정책을 종료했고 부동산 버블이 터지면서 엮여있는 금융사들이 파산하기 시작했고 이는
                세계 금융 위기로 이어졌다.
                금융 위기에 대한 정부의 대응책은 양적 완화였다. 화폐를 계속 찍어 신용창출을 하며 경제 위기를 해결했지만, 자산 버블, 인플레이션, 부의 양극화, 금융 불안정, 신흥국의 외환위기 위험
                증가 등의 부작용을 남겼다.<br>
                <br>
                반면 개인정보 관련 정부와 대기업의 행보에 반해 개인의 프라이버시를 중요시하는 사람들이 ‘시이퍼 펑크’라는 단체를 만들어 탈 중앙화된 문화를 옹호하는 사회운동을 시작했다.
                사토시 나카모토의 비트코인 백서는 사이버 펑크에 보낸 이메일를 통해 처음 세상에 선보이게 되었고, 사토시는 사이버 펑크 멤버들과 소통하며 비트코인 개발한다. <br>
                <br>비트코인의 탄생 목적은 제네시스 블록에 기록되어 있다:<br>
                <P style="font-style: italic;">The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.
                </p>
                이는 금융위기에서 영국 정부의 은행 구제금융에 대한 비판적 메세지로 다음과 같은 비트코인 탄생 목적을 말하고 있다:
                <ol>
                    <li>중앙화 금융 시스템의 블안정성과 문제점 비판</li>
                    <li>탈중앙화 금융의 대안 제시</li>
                </ol>
                블록체인은 디지털 세상에서 데이터의 신뢰를 만들어내는 신뢰의 기술이다.
                <br>나만의 문제 인식과 그 해결을 위한 블록체인 활용법에 대해 스케치 하며 공부해보자.


                </p>
            </article>

            <article>
                <h3>해시와 디지털 서명</h3>
                <p>2025년 2월 4일

                <h4>SHA-256 알고리즘 작동 과정을 알아보자.</h4>
                <ol>
                    <li>입력 데이터 준비 : 입력 데이터는 고정된 크기(512비트 블록)로 처리되고 필요한 경우 패딩을 통해 데이터를 맞춘다.</li>
                    <li>초기 해시 값 설정 : SHA-256은 8개의 32비트 초기 해시 값을 정의한다. 이 값들은 암호학적 연구를 통해 설정된 상수이고 이 값들이 초기값이 되어 64번의
                        Round를 거친 후 나오게 된다.</li>
                    <li>메시지 처리 : 입력 데이터는 512비트 블록 단위로 처리됨. 메시지 스캐줄 생성 > 해시 압축 함수(라운드 연산)</li>
                    <li>최종 출력 및 최종 해시 값 생성</li>
                </ol>

                <h4>블록 해시에는 어떤 것들이 포함되어 있을까?</h4>
                <ul>
                    <li>이전 블록의 해시 값</li>
                    <li>머클 루트: 블록 내 모든 트랜잭션의 요약 값</li>
                    <li>난이도 목표: 작업증명에 필요한 해시의 난이도</li>
                    <li>논스: 작업 증명을 완료하기 위해 반복적으로 변경되는 값</li>
                </ul>

                <h4>블록 해시 역할은?</h4>
                블록 간 연결성 유지 & 변경된 데이터 탐지

                <h4>서명의 역할은?</h4>
                문서의 진위성과 무결성 보증한다.
                서명을 함으로써 나는 이 문서를 확인했고, 문서의 내용에 동의하며, 문서가 변조되지 않았음을 보증한다는 의미를 전달한다.

                <h4>디지털 서명은 어떻게 이루어지나?</h4>
                <ul>
                    <li>발신자가 개인키를 사용해 서명</li>
                    <li>수신자는 공개키로 서명을 검증해 데이터의 진위성과 무결성을 확인한다.</li>
                    <ul style="list-style-type: circle;">
                        <li>진위성 확인: 데이터를 서명한 사람이 신뢰할 수 있는 발신자인지</li>
                        <li>무결성 보증: 데이터가 전송 중 변조되지 않았는지</li>
                    </ul>
                </ul>

                <h4>디지털 서명은 어떻게 진행될까요?</h4>
                <ol>
                    <li>데이터 해싱</li>
                    <li>서명: 송신자는 개인티로 해시 값에 서명함. 이 서명은 암호화된 해시값으로 서명자는 해당 데이터의 무결성과 진위성 보증 (디지털 서명은 개인키로 암호화 되었기 때문에
                        공개키로 복호화 할 수 있고, 복호화하면 원본 데이터의 해시 값이 나옴)</li>
                    <li>검증 : 수신자는 송신자의 공개키로 디지털 서명을 복호화 함. 검증 과정에서 다음 두 데이터 비교.</li>
                    <li>송신자의 공개키로 디지털 서명을 복호화 해서 원본 데이터의 해시값 구함</li>
                    <li>원본 데이터를 해싱해 데이터의 해시값을 구함. 위 해시값과 같다면 데이터가 정상적으로 송신자에 의해 서명된 것임.</li>
                </ol>
                <h4>디지털 서명 시스템의 필요조건은?</h4>
                <ul>
                    <li>알고리즘 : 신뢰할 수 있고 널리 사용되어 그 안전성이 입증된 해시 함수(SHA-256, SHA-3 등)와 암호화 알고리즘(RSA, ECDSA)을 사용해야 함</li>
                    <li>구현: 알고리즘 자체는 안전하더라도 소프트웨어나 하드웨어 구현상의 취약점이 보안 사고로 이어질 수 있음</li>
                    <li> 개인 키 : 개인키 유출이나 손상 > 진위성과 부인 방지 속성 무효화됨</li>
                </ul>

                <h4>타임스탬프에서 디지털 서명의 사용 목적:</h4>
                <ul>
                    <li>데이터 무결성 증명(특정 시점 이후 변하지 않았음, 디지털 서명으로 변조 여부 검증)</li>
                    <li>시간 인증(TSA가 인증)</li>
                    <li>신뢰 제공(인증 기관의 신뢰를 바탕으로 데이터 진위 보증)</li>
                </ul>

                <h4>디지털 서명의 사용과정은?</h4>
                <ol>
                    <li>데이터 해싱</li>
                    <li>타임스탬프 생성 (TSA에서 서명해 유저에게 반환)</li>
                    <li>검증: 데이터 해싱 > 반환된 타임스탬프의 디지털 서명과 비교해 TSA의 공개키를 사용해 서명이 유효한지 검증하고 데이터 해시 값이 타임스탬프에 기록된 해시값과 동일한지
                        확인 > 데이터가 특정 시점 이후 변경되지 않았음을 증명</li>
                </ol>

                <h4>비트코인에서 디지털 서명의 역할은?</h4>
                (1) 트랜잭션 무결성 보장 (2) 소유권 증명 (3) 탈중앙화된 검증

                <h4>비트코인에서 디지털 서명의 생성 및 검증 과정에 대해 설명하세요.</h4>
                <ol>
                    <li>서명 생성:
                        <ol style="list-style-type: lower-alpha;">
                            <li>트랜잭션 데이터 준비</li>
                            <li>해싱</li>
                            <li>송신자의 개인키 사용한 해시 값 서명</li>
                            <li>서명과 트랜잭션 데이터 전송</li>
                        </ol>
                    <li>서명 검증:
                        <ol style="list-style-type: lower-alpha;">
                            <li>검증 노드가 트랜잭션 데이터 해싱</li>
                            <li>공개 키를 사용한 검증: 서명이 유효한지, 송신자 개인키로 생성된 서명인지, 트랜젝션 데이터가 변조되지 않았는지 확인</li>
                            <li>검증 결과 (서명이 유효하면 네트워크에 추가)</li>
                            <li>만약 두 해시값이 다르다면, 송신자의 개인키로 생성된 서명이 아니거나 데이터가 변조되었을 가능성.</li>
                        </ol>
                </ol>

                <h4>앨리스가 밥에게 0.1 BTC를 보냅니다. 트랜잭션 생성 ~ 블록체인에 추가되는 과정을 설명하세요.</h4>
                <ol>
                    <li>앨리스가 0.1 BTC 보내려는 트랜잭션 생성</li>
                    <li>트랜잭션 해시 값을 자신의 개인 키로 서명</li>
                    <li>서명된 트랜젝션을 네트워크에 전송</li>
                    <li>네트워크의 노드가 이 트랜잭션 데이터를 해싱해서 동일한 해시 값 생성</li>
                    <li>공개 키를 사용해 서명 검증</li>
                    <li>서명이 유효하면 트랜젝션을 블록체인에 추가</li>
                </ol>

                <h4>디지털 서명의 장점은?</h4>
                (1) 보안성(위조 불가능), (2) 무결성 보장(만약 데이터 변조되면 서명이 유효하지 않음), (3) 부인 방지, (4) 신뢰 기반 탈중앙화</br>

                <h4>비트코인에서 디지털 서명 활용의 특징은?</h4>
                <ul>
                    <li>ECDSA 사용</li>
                    <li>공개 키 -> 주쇼 변환 (SHA-256 + RIPMED-160)</li>
                    <li>비교적 작은 서명 크기(64비트)</li>
                </ul>
                <br>

                </p>
            </article>

            <article>
                <h3>블록체인의 기본 구조</h3>
                <p>
                    2025년 2월 5일<br><br>
                <h4>블록은 무엇으로 이루어져 있나요?</h4>
                헤더와 바디

                <h4>블록 헤더는 왜 필요한가요?</h4>
                블록에 대한 메타데이터 포함하고 있고, 블록의 고유 식별자 역할을 하기 때문.<br>
                구성: 이전 블록 해시(연결성), 머클 루트(루트 해시 값), 타임스탬프, 난이도 타켓, 논스, 버전

                <h4>블록 바디에는 무엇이 있나요?</h4>
                트랜잭션 (코인베이스 트랜잭션와 일반 트랜잭션)

                <h4>트랜잭션 흐름에 대해 간략하게 설명하세요.</h4>
                <ul>
                    <li>입력: 송신자가 이전 트랜젝션 출력(UTXO)를 참조하고, 지출할 UTXO 정보 등을 포함한 인풋에 개인 키로 디지털 서명을 한다</li>
                    <li>출력: 출력 금액 등의 정보를 포함한 아웃풋에 수신자의 주소를 지정하는 잠금 스크립트를 만든다</li>
                    <li>수신: 수신자가 공개키와 서명을 제공해 잠금 스크립트를 해제한다</li>
                    <li>검증: 노드가 입력과 출력을 검증한다</li>
                </ul>

                <h4>비트코인 UTXO 모델에서 내 계좌에 10,000원이 있는데 밥에게 3,000원을 송금했다. 이 과정을 설명하세요.</h4>
                <ul>
                    <li>내가 갖고 있던 10,000의(UTXO) 상태가 “사용됨(입력, Input)”으로 변하고,</li>
                    <li>밥에게 3,000(UTXO)이 “미사용됨(출력, Output)”으로 생성된다</li>
                    <li>내 계좌에는 수수료를 뺀 나머지 69999.999원(UTXO)이 “미사용됨(출력, Output)”으로 생성된다.</li>
                    <li>비트코인은 필요한 금액만큼 UTXO을 소모하고 잔액은 새로운 UTXO로 생성됨.</li>
                </ul>

                <h4>UTXO란?</h4>
                <li>Unspent Tranxaction Output의 약자로 이전 트랜잭션에서 생성되었지만 아직 소비되지 않은 출력을 말한다.</li>
                <li>내 지갑이 모든 UTXO를 더하면 잔고가 된다.</li>
                <li>이미 소비된 UTXO는 다시 사용할 수 없어 "이중지불" 방지의 역할을 한다.</li>

                <h4>이더리움과 비트코인의 차이점은?</h4>
                비트코인은 UTXO기반 모델이고 이더리움은 계정 기반 모델임.<br>
                비트코인과는 달리 이더리움에서는 반복문을 쓸 수 있어 스마트 컨트랙트를 만들기 더 용이하다. 해커의 공격을 막기 위해 가스비를 도입해 공격할 때마다 가스비를 써야 하도록 설계했다.<br>

                <h4>OP 코드로 각 트랜잭션이 올바르게 작동하는지 검증할 때 어떤 것을 보나요?</h4>
                소유자 확인, 출력 주소와 금액 확인, 다중 서명 및 공개 키 변조 방지

                <h4>머클 루트는 어떤 역할을 하나요?</h4>
                마클 트리에서 하나의 트랜잭션만 변경해도 머클 루트가 변함으로써 데이터 무결성을 보장하고 위변조를 방지합니다.
                </p>
            </article>

            <article>
                <h3>블록체인의 작동원리</h3>
                <p>2025년 2월 6일</p>

                <h4>사토시 나카모토는 중앙 집중형 원장의 어떠한 특징을 해결하고 싶어했나요?</h4>
                <ul>
                    <li>중앙화된 신뢰: 데이터의 신뢰가 국가와 같은 중앙 기관의 신뢰성과 권위를 기반으로 형성되는 점</li>
                    <li>단일 장애점: 중앙 서버가 해킹, 손상, 장애를 겪으면 데이터가 유실되거나 손상될 위험이 있음.</li>
                    <li>투명성 부족</li>
                </ul>

                <h4>중앙 집중형 원장의 특징 중 어떤 것이 사타시 나카모토의 최우선 과제가 아니었나요?</h4>
                <li>율성: 중앙 기관이 직접 데이터를 관리해서 처리 속도가 빠를 수 있음</li>

                <h4>분산원장이란 무엇인가요?</h4>
                <li>데이터를 중앙 서버가 아닌 네트워크의 여러 노드에 걸쳐 분산 저장하는 데이터베이스의 일종. 중앙기관 없이 데이터의 무결성과 보안이 유지됨.</li>

                <h4>분산원장의 종류로 어떤 것이 있나요?</h4>
                <ul>
                    <li>퍼블릭 (예: 비트코인, 이더리움)</li>
                    <li>프라이빗: 제한된 참여자만 접근 가능. 기업 내부에서 사용됨. (예: 하이퍼레저, 리플)</li>
                    <li>컨소시엄: 특정 그룹(기업 연합 등) 내에서 공유되며, 참여 노드가 제한됨.</li>
                </ul>

                <h4>중앙 집중형 원장과 분산원장의 대표적 차이점 몇 가지를 얘기해보세요.</h4>
                <ul>
                    <li>데이터 추가/수정 가능 여부: 중앙 집중형 원장에서는 가능, 비트코인에서는 불가능</li>
                    <li>신뢰 형성 방법: 중앙 집중형에서는 중앙 기관의 권위 사용, 비트코인에서는 합의 알고리즘과 암호화 기술 사용</li>
                    <li>확장성: 중앙 집중형에서는 높음(중앙화된 처리), 비트코인에서는 낮음(분산 처리로 인한 제한)</li>
                </ul>

                <h4>합의 알고리즘이란?</h4>
                <li>무엇이 우선시 되어야 하는가를 정의하는 것. 예를들어 블록이 포크 되었을 때 무엇을 우선시 해야 할까? 비트코인의 경우 작업을 많이 한 체인이 우선시 됨.</li>

                <h4>분산 원장 기술의 작동 방식을 설명하세요.</h4>
                <ol>
                    <li>트랜잭션 생성</li>
                    <li>트랜잭션이 모든 노드에 전파됨</li>
                    <li>협의 과정: 노드들이 합의 알고리즘을 통해 해당 트랜젝션의 유효성 검증</li>
                    <li>데이터 저장: 검증된 트랜잭션 원장에 기록; 노드 동기화</li>
                </ol>

                <h4>노드란?</h4>
                블록체인 네트워크에 연결된 장치.PC.

                <h4>노드는 어떤 역할을 하나요?</h4>
                데이터 저장, 데이터 검증 (블록의 유효설 검증), 네트워크 연결 및 데이터 전파, 합의 참여

                <h4>노드 유형으로 어떤 것이 있나요?</h4>
                <ul>
                    <li>풀노드 (예: 비트코인 코어 노드)</li>
                    <li>라이트 노드, SPV 노드: 머클 루트를 포함한 블록 헤더만 저장하여 작동함; 트랜젝션 검증을 위해 다른 풀 노드 필요; 예: 모바일 지갑 앱</li>
                    <li>마이닝 노드: 작업 증명을 수행해 새 블록 생성. (예: 지난 실습에서 풀노드에서는 비트코인 데몬을 켜 놓고, 마이닝 노드는 비트코인 블록을 생성 했었음)</li>
                </ul>

                <h4>알트코인에서 볼 수 있는 노드로 어떤 것이 있나요?</h4>
                <ul>
                    <li>검증 노드: 지분 증명 네트워크에서 블록 생성 및 검증. 예: 이더리움 2.0, 폴카닷, 솔라나</li>
                    <li>아카이브 노드: 블록체인의 모든 기록과 상태 데이터 자장. 주로 스마트 컨트랙트가 실행되는 블록체인(예: 이더리움, 폴카닷, 솔라나) 에서 사용됨.</li>
                </ul>

                <h4>비잔틴 장군 문제에 대해 얘기해보세요.</h4>
                <ul>
                    <li>4개 군대가 힘을 합쳐 포위하고 있는 적군의 성을 함락해야 함.</li>
                    <li>4개 군대고 동시에 공격해야만 성을 함락할 수 있음. 만약 한 군대가 배신해서 동시에 공격 못 하면 작전 실패.</li>
                    <li>해결: 각 국대가 모든 군대에게 메세지를 전파한다. > 다수결로 공격 성공</li>
                    <li>레슬리 램포트의 해법: 네트워크의 노드가 3n+1 이상이어야 최대 n명의 배신자기 있어도 합의 가능하다</li>
                </ul>

                <h4>분산된 네트워크 환경에서 악의적인 노드(배신자)가 존재할 때 이를 어떻게 극복하고, 정직한 참여자들이 올바르게 합의에 도달할 수 있을까?</h4>
                <ul>
                    <li>비잔틴 장애 허용(BFT): 네트워크 내 일부 노드가 악의적이거나 오류를 발생시켜도 나머지 정직한 노드가 올바른 합의에 도달하여 시스템이 정상적으로 작동하도록 보장하는
                        메커니즘.</li>
                    <li>한마디로 악의적 노드가 있어도 돌아가는 시스템을 돌아가게 하자는 것.</li>
                </ul>

                <h4 style="text-decoration: underlinep; color: orchid;">블록이 생성되는 과정을 설명해보세요.</h4>
                <ol>
                    <li>트랜잭션 생성 > 모든 노드트랜잭션 수집: 마이닝 노드가 전파된 트랜잭션을 수집해 메모리 풀에 저장</li>
                    <li> 블록 템플릿(임시 블록) 생성: 피라미드 쌓기</li>
                    <li>작업 증명(PoW): 블록 헤더의 해시값이 네트워크에서 요구하는 난이도 목표 이하의 값이 되도록 논스 값을 변경하며 반복적으로 해시 계산</li>
                    <li>블록 검증 및 전파: 유효한 해시값을 찾으면 블록이 채굴(생성)됨. > 브로드캐스트 > 다른 노드들이 새 블록의 유효성 검증</li>
                    <li>블록체인에 추가</li>
                    <li>보상 지급: 코인베이스 트랜잭션</li>
                    <li>새 블록 이후 체인 확장에 전파(브로드캐스트)</li>
                </ol>

                <h4>작업증명이 뭔가요?</h4>
                네트워크 참여자(마이너)가 퍼즐 게임에 참여해 먼저 퍼즐을 푸는 사람이 보상을 받는 경쟁적 구조.

                <h4>PoW 작동 방식을 설명하세요.</h4>
                <ol>
                    <li>트랜잭션 모으기</li>
                    <li>퍼즐 문제 해결</li>
                    <li>블록 검증</li>
                    <li>보상 지급급</li>
                </ol>

                <h4>Hash Puzzle에 사용되는 값은? 마이너는 아래 값들을 하나의 값으로 모아서 SHA-256 해시 함수를 실행함.</h4>
                <ul>
                    <li>이전 블록의 해시</li>
                    <li>머클 루트</li>
                    <li>타임 스탬프 : 이전 블록의 타임스탬프보다 크고 네트워크 현재 시간보다 2시간 이내여야 함.</li>
                    <li>난이도: 네트워크에서 설정 (예: 비트코인 목표는 10분마다 1개 블록 생성); 블록 해시 값 앞 부분에 0이 몇 개인지가 중요</li>
                    <li>논스 : 유효한 해시를 찾기 위해 반복적으로 변경되는 값; 유일한 변수</li>
                </ul>

                <h4>체인 분기(Fork)는 왜 발생하나요?</h4>
                <li>두 명의 채굴자가 동시에 블록 생성 및 브로드캐스트</li>
                <li>네트워크 지연으로 일부 노드가 특정 블록을 먼저 수신하고 다른 블록을 뒤늦게 수신했을 경우</li>

                <h4>분기 상태에 대해 설명하세요.</h4>
                <li>두 체인의 길이가 동일하며 각각 다른 노드 그룹에서 다른 체인을 유효한 체인으로 인식하는 일시적인 상태.</li>
                <li>네트워크는 가장 긴 체인(또는 가장 많은 작업량을 포함한 체인)을 신뢰하며 새 블록이 추가됨에 따라 다음 블록을 채굴하기 위한 작업이 반복됨.</li>

                <h4>체인 리오르그(Chain Reorganization)이란?</h4>
                분기 체인 중 가장 긴 체인 선택하는 과정. 가장 긴 체인이 메인 체인으로 선택되면, 기존의 짧은 체인의 블록들은 무효화되고 버려진 블록, 즉 고아 블록이 됨. 이 고아 블록들은 다시
                멤풀로 반환되어 다른 블록에 포함될 기회를 얻게 됨.

                <h4>PoW의 장단점에 대해 말하시오.</h4>
                <ul>
                    <li>장점1: 높은 보안성</li>
                    <li>장점2: 검증 용이성(블로 헤더의 해시 값을 계산해 블록이 타켓 값 조건을 만족하는지 확인)</li>
                    <li>단점1: 에너지 소모가 큼</li>
                    <li>단점2: 확장성 문제(비트코인은 초당 약 7건의 트랜잭션 처리 할 수 있어 대규모 사용자 지원 어려움)</li>
                    <li>단점3: 높은 진입 장벽(고성능 하드웨어와 막대한 전력 비용)</li>
                    <li>단점4: 중앙화 위험</li>
                </ul>

                <h4>만약 공격자가 PoW 네트워크의 해시 파워의 51% 이상을 장악하면 어떤 일이 벌어지나요?</h4>
                <li>블록 생성 독점</li>
                <li>이중 지불: 이전 트랜잭션 취소하고 새 체인을 생성해 코인을 다시 사용</li>
                <li>네트워크 방해 : 다른 채굴자들이 유효한 블록을 생성하지 못하도록 방해.</li>

                <h4>PoS에 대해 설명하세요.</h4>
                지분증명. 네트워크 참여자의 지분을 기준으로 블록을 생성하고 합의를 이루는 방식.<br>
                PoW와는 달리 에너지 효율성과 확장성이 높음.

                <h4>PoS 네트워크에서 블록이 생성되는 과정은?</h4>
                <ol>
                    <li>지분 기반 참여: 스테이킹</li>
                    <li>검증자 선택: 네트워크는 무작위 알고리즘으로 블록 생성자 선택. 선택 기준은 스테이킹된 코인의 양과 코인을 스테이킹한 기간.</li>
                    <li>블록 검증 및 추가: 선택된 검증자가 블록 생성하면 나머지 검증자가 이를 검증하여 블록체인에 추가</li>
                </ol>

                <h4>PoS의 장단점에 대해 말하시오.</h4>
                장점: 에너지 효율, 확장성(블록 생성 속도 빠름), 보안성(경제적 페널티)<br>
                단점: 지분 집중화 문제(초기 지분 많으면 유리), 복잡성(구현 및 운영 복잡)

                <h4>PoS의 보안성에 대해 설명하세요. 다음 두 보안 장치가 있음.</h4>
                <ul>
                    <li>Slashing: 악의적 검증자는 스테이킹된 자산을 잃을 위험이 있음. (예: 이더리움 2.0)</li>
                    <li>51% 공격 방지: PoW에서는 해시 파워 과반수를 장악해야 하지만, PoS에서는 네트워크의 과반수 지분을 확보해야 함.</li>
                </ul>

                <h4>Nothing at Stake 문제란?</h4>
                <ul>
                    <li>PoS 블록체인에서 검증자가 여러 체인에 동시에 서명해 네트워크의 신뢰성/일관성을 저하시킬 위험.</li>
                    <li>문제 원인: PoW와 달리 경제적 비용 없이 여러 체인에서 작업할 수 있는 구조.</li>
                    <li>문제의 결과: 합의 실패(혼란), 체인 분기로 인한 보안 위협(이중지불, 정당한 거래가 무효화될 가능성), 네트워크 신뢰 손상</li>
                </ul>

                <h4>PoS에서 Nothing at Stake 문제 해결 방안</h4>
                <ul>
                    <li>경제적 패널티(Slashing)</li>
                    <li>체인 선택 규칙 : Longest Chain Rule - 가장 긴 체인(또는 가능 많은 작업 증명을 포함한 체인)이 유효한 체인.</li>
                    <li>경제적 인센티브 설계</li>
                    <li>검증자 서명 공개</li>
                </ul>

                <h4>DPoS(위임 지분 증명)이 무엇인가요?</h4>
                PoS에서 고래만 계속 블록생성할 위험 (중앙화 위험)을 해결하기 위해 만들어진 것.<br>
                대표자(Delegate)를 선출해 블록 생성과 검증을 맡기고 이 대표자가 네트워크 블록 생성과 검증을 담당하는 합의 알고리즘.<br>
                PoS 효율성 개선과 PoW 탈중앙화 유지를 목표로 설계됨.

                <h4>DPoS 작동방식 설명하세요.</h4>
                <ul>
                    <li>대표자 선출.: 사용자가 지분을 위임하여 투표로(내 코인으로) 대표자 선출 (예: EOS)</li>
                    <li>블록 생성과 검증: 대표자들이 번갈아 가며 블록 생성; PoS처럼 복잡한 해시 계산이 필요 없어 블록 생성 속도가 매우 빠름</li>
                    <li>보상 분배: 대표자는 블록 생성으로 받은 보상을 자신에게 투표한 사용자와 공유함</li>
                    <li>대표자 교체: 사용자는 언제든 자신의 투표를 변경해 대표자 교체 가능</li>

                </ul>

                <h4>DPoS의 장단점에 대해 설명하세요.</h4>
                장점: 소수의 대표자가 블록을 생성해 블록 생성과 검증 속도가 빠름; 에너지 효율; 미국 대통령 선출 방식처럼 민주적 구조; 실시간 부정직한 대표자 빠르게 교체 가능
                <br>단점: 대표자 담합 등 중앙화 가능성; 낮은 투표 참여율; 대표자 신뢰 문제

                <h4>DPoS 블록체인 사용하는 곳은?</h4> EOS, Tron, Steem

                <h4>DPoS의 보안 장치는?</h4>
                대표자 교체 가능; 경제적 인센티브 (부정행위시 신뢰 잃고 보상 못 받음; Slashing); 투명성

                <h4>채굴이란?</h4>
                블록체인 네트워크에서 노드로 새로운 불록을 생성하여 체인에 연결하고 보상을 받는 것

                <h4>반감기의 역할은?</h4>
                채굴 보상이 주기적으로 절반으로 줄어들게 함으로써 암호화폐의 공급량을 조절하고 희소성을 유지하며, 궁극적으로 암호화폐의 가치를 보호함.

                <h4>거래수수료는 누구에게 주나요?</h4>
                채굴자와 검증자에게 보상을 지급
                <br>PoW에서는 채굴자에게만, PoS에서는 검증자에게만

                <h4>거래 수수료는 어디에 쓰여요?</h4>
                네트워크상의 스팸 공격 줄이기; 거래 수수료로 트랜잭션을 확인하고 유효성을 검증하는 사용자에게 인센티브를 제공함


                <h4>비트코인의 채굴자를 이더리움에서 뭐라고 부를까요?</h4> 블록 제안자(proposer)


                <h4>채굴풀이란?</h4>
                채굴을 위해 만들어진 조합<br>
                채굴 풀의 위험성(51% 공격) 을 극복한 좋은 사례: GHash.IO - 탈중앙화를 지키기위해 스스로 51% 이하로 해시 파워를 줄인 사례

                /////


            </article>

            <article>
                <p>
                <h3>이더리움</h3>
                <p>
                    2025년 2월 7일
                </p>
                <h4>튜링 기계계</h4>
                앨런 튜링(Alan Turing)이 제안한 가상의 계산 모델<br>
                모든 계산 가능한 문제를 모델링할 수 있는 이론적 컴퓨터.

                <h4>튜링 완전성에 대해 설명하세요.</h4>
                <ul>
                    <li>토스트기 밖에 없는 주방에서는 빵 굽기 밖에 못함 (튜링 불완전함)</li>
                    <li>모든 도구와 리소스가 있는 주방에서는 어떤 요리도 가능함 (튜링 완전함)</li>
                    <li>계산기 vs. 컴퓨터</li>
                    <li>반복문과 조건문이 가능해야 튜링 완전함.</li>
                    <li>즉, 튜링 완전성은 튜링 기계와 같은 계산 능력을 가졌음을 의미한다. 어떤한 계산 가능한 문제도, 적절한 알고리즘과 충분한 리소스(시간과 메모리)가 주어진다면 해결할 수
                        있다.</li>
                    <li>블록체인에서 튜링 완전성을 가진 플랫폼은 더 많은 유연성을 제공하지만 동시에 더 많은 책임과 위험 관리가 필요함.</li>
                </ul>

                <h4>이더리움은 튜링 완전한가?</h4>
                네, 이더리움의 EVM은 튜링 완전성을 지원해 복잡한 스마트 계약 생성을 가능하게 함.<br>
                튜링 완전해서 생길 수 있는 문제: (1) 무한 루프 문제(이를 막기 위해 가스 제한을 둠), (2) 보안 취약점 발생 가능

                <h4>비탈릭 부테린은 왜 이더리움을 만들었나요?</h4>
                프로그래밍 가능한 블록체인을 만들겠다는 목표로 (비트토인 op 코드 몇 개로는 그러기 어려움)

                <h4>이더리움 핵심 목표는 무엇인가요?</h4>
                <ul>
                    <li>스마트 계약</li>
                    <li>DApps</li>
                    <li>프로그래밍 가능성 : 튜링 완전한 언어(Solidity)를 통해 블록체인 상에서 복잡한 프로그램 구현 가능</li>
                </ul>

                <h4>이더리움은 왜 프로그래밍이 가능한 블록체인일까?</h4>
                <ul>
                    <li>스마트 계약: Solidity와 같은 프로그래밍 언어로 작성되며, 특정 규칙을 코딩하고 이를 블록체인에 배포하여 실행할 수 있음. > 다양한 DApps을 실행할 수 있는
                        플랫폼이 됨.</li>
                    <li>EVM: 이더리움 네트워크에서 스마트 계약을 실행하는 환경.</li>
                    <li>튜링 완전성: 스마트 계약이 튜링 완전한 언어로 작성됨. > 계약이 매우 유연하고 강력한 기능을 제공할 수 있음.</li>
                </ul>

                <h4>비트코인과 이더리움은 설계 목적이 어떻게 다른가?</h4>
                비트코인: 디지털 통화(가치 저장 및 거래)가 목적. 단순하고 안정적인 네트워크 설계<br>
                이더리움: 스마트 계약 및 DApp 실행이 목적. 유연하고 확장 가능한 네트워크 설계.

                <h4>ECDSA가 뭔가요?</h4>
                <li>타원 곡선 암호학을 기반으로한 디지털 서명 알고리즘.</li>
                <li>기존 RSA보타 짧은 키 길이로도 높은 보안성을 제곰하며, 개인키로 서명을 생성하고 공개키로 이를 검증하는 방식으로 동작함.</li>
                <li>장점: 속도와 보안성을 동시에 확보할 수 있음.</li>
                <li>비트코인, 이더리움에서 거래 서명과 인증에 쓰임.</li>

                <h4>이더리움의 블록체인 모델은 비트코인과 어떻게 다른가요?</h4>
                비트코인은 UTXO 기반 모델, 이더리움은 계정 기반 모델<br>
                비트코인 모델에서는 UTXO 합이 잔액임, 이더리움에서는 계정 잔액.

                <h4 style="text-decoration: underline; color:#ff4d94;">이더리움 계정의 종류 2가지는 무엇인가요?</h4>
                <ul>
                    <li>외부 소유 계정(EOA): 사람이 씀. 프라이빗 키가 있어 디지털 서명 할 수 있고 트랜젝션 생성 할 수 있음.</li>
                    <li>스마트 계약 계정(CA): 특정 코드가 배포된 계정. 프라이빗 키가 없어서 트잭 생성 못함 (출금 못함). 스스로 트잭 생성은 못하지만 EOA가 요청한 트랜젝션 만들 수는
                        있음 (인터널 트랜잭션).</li>
                </ul>

                <h4 style="text-decoration: underline; color:#ff4d94;">이더리움의 논스와 비트코인의 논스는 어떻게 다른가요?</h4>
                <ul>
                    <li>해당 계정에서 보낸 트랜잭션의 횟수/순서 (비트코인에서는 시도 횟수로 PoW 채굴 과정에서 유효한 해시를 찾기 위해 사용)</li>
                    <li>이중지불을 비트코인에서는 UTXO로 방지 - 사용된 UTXO 값은 더하지 않음. 미사용된거 합치면 잔액. 이미 소모된 UTXO를 다시 사용하는 트잭은 유효하지 않고
                        네트워크에서 거부됨.</li>
                    <li>이중지불을 이더에서는 논스로 막음. 즉 재생 공격(replay attack)을 방지함.</li>
                    <li>이더리움의 논스는 계정별 트랜잭션의 고유 식별자 역할을 함.</li>
                </ul>

                <h4>이더리움에서 재생 공격 방지 방법은?</h4>
                <ul>
                    <li>논스 사용</li>
                    <li>체인 ID: 포크된 체인에서 체인 ID를 도입해 각 체인을 구분함. 예: 이더리움과 이더리움 클래식은 서로 다른 체인 ID 사용</li>
                </ul>

                <h4>EVM이란?</h4>
                <ul>
                    <li>Ethereum Virtual Machine. 우리가 작성한 코드와 이더리움 블록체인 사이에 존재하는 가상 머신.</li>
                    <li>여행갈 때 가져가는 어댑터</li>
                    <li>이더리움에서 스마트 계약 기반의 dApp은 Solidity로 작성됨. Solidity 코드를 Solidity 컴파일러(solc)를 사용해 EVM이 이해할 수 있는
                        Bytecode로 변환. -> 바이트코드를 이더리움 네트워크로 배포. -> EVM이 바이트코드를 해석하고 실행함.</li>
                </ul>

                <h4>EVM에서 바이트코드는 스택 기반 아키텍처로 실행됩니다. 바이트코드가 실행되는 과정을 설명해보세요.</h4>
                EVM은 명령어를 Opcode로 해석하며 모든 연산은 스택을 이용해 처리됨.<br>
                스택, 즉 프링글즈 과자처럼 먼저 들어온 대로 쌓아 올리고, 맨 마지막에 올린 것 부터 꺼냄.

                <h4>EVM에는 보안을 위한 어떤 장치가 있나요?</h4>
                <li>보안 격리(Sandboxing): 스마트 계약 간 충돌을 방지하며, 잘못된 코드가 네트워크나 다른 계약에 영향을 미치지 않도록 격리된 실행 환경을 제공함.</li>
                <li>가스(Gas): 바이코드 실행에는 가스 비용이 소모됨. 각 Opcode는 실행 비용에 따라 특정 가스 양이 할당됨.</li>

                <h4>스마트 컨트랜트란?</h4>
                <ul>
                    <li>블록체인 네트워크에서 호스팅되고 실행되는 프로그램으로, 특정 조건을 설정하고 해당 조건이 충족되면 자동으로 계약을 이행하도록 설계된 자동화된 계약 실행 프로토콜임.</li>
                    <ul>
                        <li>프로토콜: 컴퓨터나 네트워크 시스템이 데이터를 주고받을 때 따르는 규칙과 절차. 데이터 전송 방식, 오류 처리, 인증 절차 등을 표준화하여 다른 시스템간 원활한
                            통신을 가능하게 함. 디지털 세계에서 ‘언어’와도 같은 역할을 함.</li>
                    </ul>
                    <li>블록체인의 분산 구조와 암호화 기술로 인해 계약 조건이나 이행 내용을 변조하기 어렵고, 계약을 신뢰하기 위한 제3자가 필요하지 않음.</li>
                    <li>닉 재보의 정의: 계약 조건을 실행하는 전산화된 트랜잭션 프로토콜은 일반적인 계약 조건을 만족하고, 악의적이거나 우발적인 예외를 최소화하며, 신뢰할 만한 중개자의 필요성을
                        최소화 하는 것을 목표로 한다. 마치 자판기와 같다.</li>
                </ul>

                <h4>스마트 컨트랙트가의 장점이 뭔가요? 일반적인 중앙집권화된 디지털 계약과 비교해 설명하세요.</h4>
                <ul>
                    <li>보안: 분산형 블록체인에서 실행되어 Single point of failure 위험이 없음.</li>
                    <li>신뢰성: 모드 노드에 의해 검증되어 계약 위변조가 매우 어려움.</li>
                    <li>공평함: 수수료 없고, 특정 용의적 목적의 제3자가 필요 없음.</li>
                    <li>효율성</li>
                </ul>

                <h4>스마트 컨트랙트의 한계점은?</h4>
                <ul>
                    <li>배포 후 작동 수정이 불가능함: 보안 허점이 발견될 경우 해킹에 취약해 질 수 있음. 프록시 패턴과 같은 컨트랙트 업그레이드 방법이 개발되었으나 완벽한 해결책은 아님.
                    </li>
                    <li>블록체인 외 정보를 스스로 얻지 못함. 오라클을 사용하지만, 그 데이터가 신뢰할 수 있는지, 전달 과정에서 오류가 발생하지 않는지 확인해야 함. 악의적인 데이터 입력 시
                        계약이 의도하지 않은 방식으로 실행될 위험도 있음.</li>
                </ul>

                <h4>지갑에 EVM 계열 블록체인 노드를 어떻게 연결하나요?</h4>
                지갑은 특정 노드의 RPC URL(노드 주소)을 이용해 블록체인에 저장된 온체인 데이터를 요청할 수 있음. 이러한 노드와의 통신 방식은 RPC(Remote Procedure
                Call)이라고 하며 RPC URL을 통해 연결함.

                <h4>메타마스크에서 다른 지갑 주소로 KAIA 보내며 컨펌을 누르면 어떤 일이 벌어지나요?</h4>
                <ol>
                    <li>트랜젝션 세부 정보가 명확히 표시됨. 유저는 승인 진행</li>
                    <li>개인키로 트랜잭션에 디지털 서명</li>
                    <li>서명된 트랜잭션은 네트워크로 브로드캐스트 되어 처리됨</li>
                    <li>네트워크가 트랜잭션 처리하고 블록에 포함한 뒤 상태 업그레이드</li>
                </ol>
                </p>
            </article>


            <article>
                <h3>기초 - 웹 개발 이해하기</h3>
                <p> 2025년 2월 10일</p>
                <h4>웹이란?</h4>인터넷 위에서 동작하는 정보 시스템

                <h4>인터넷과 웹은 어떻게 다른가?</h4>
                인터넷은 도로, 웹은 도로를 달리는 자동차. <br>
                인터넷은 물리적 네트워크 인프라, 웹은 웹 브라우저를 통해 사람들이 정보를 검색, 읽기, 쓰기 할 수 있고 상호작용할 수 있는 공간

                <h4>웹은 왜 만들어 졌나요? (어떤 문제를 해결하기위해 만들어졌나요?)</h4>
                각 과학 연구소마다 다른 시스템으로 데이터 저장 및 접근 > 데이터 찾고 이해하기 위해 시간과 노력 많이 소요. > 하나의 통합된 플랫폼을 통해 데이터 공유하고 접근 가능성 높일 필요성

                <h4>군사나 학술 목적으로 사용되던 인터넷이 언제부터 확산화되기 시작했나요?</h4>
                <ul>
                    <li>1983년 TCP/IP 프로토콜이 만들어 지면서.</li>
                    <li>TCP/IP 프로토콜: 우리만의 규약.</li>
                    <li>데이터를 패킷화, 주소 지정 및 전송, 라우팅, 수신하는 방법에 대한 일련의 규칙 제공 (마치 택배 배달 하는 것처럼)</li>
                </ul>

                <h4>팀 버너스가 제안한 www의 개념을 설명하세요.</h4>
                <ol>
                    <li>하이퍼텍스트(링크)의 활용</li>
                    <li>인터넷을 활용한 글로벌 정보 공유</li>
                    <li>웹의 구성 요소 - HTML: 웹 문서 구조 정의; 태그 기반 언어이고 태그 안에는 약속된 기능이 있음</li>
                    <ul>
                        <li>HTTP: 클라이언트와 서버 간에 데이터를 주고받는 프로토콜; 요청과 응답 구조</li>
                        <li>URL: 웹 리소스의 위치를 정하는 주소</li>
                        <li>URL 구조: 프로토콜://도메인/경로?쿼리문자열# 프래그먼트</li>
                        <ul>
                            <li>프로토콜: 데이터를 주고받는 방식</li>
                            <li>도메인: 서버 주소 또는 IP 주소</li>
                            <li>경로: 서버 내에서 자원의 위치</li>
                            <li>프래그먼트: 문서 내 특정 위치</li>
                        </ul>
                    </ul>
                </ol>

                <h4>현재 웹 표준을 담당하는 기관은 어디인가요?</h4>팀 버너스 리가 주도하는 W3C(World Wide Web Consortium)

                <h4>Web의 발전 과정을 설명하세요. </h4>
                <ol>
                    <li> Web 1.0 - 사용자가 데이터를 받는다. 예: 게임 공지</li>
                    <li>Web 2.0 - 사용자도 데이터 만들고 공유할 수 있다. 예: 홈페이지</li>
                    <li>Web 3.0 - 지능화, 개인화, 탈중앙화를 중심으로 하는 차세대 웹.</li>
                    <ul>
                        <li>사용자의 데이터 소유권과 분산 네트워크 강조</li>
                        <li>블록체인, AI, 스마트 계약, 시맨틱 웹</li>
                        <li>확장성 문제: 네트워크가 커질수록 처리 속도가 느려지는 문제</li>
                        <li>네트워크 속도 문제: 블록체인은 전 세계 노드 간 데이터 전파가 필요하며, 인터넷 속도가 느려면 합의 과정이 지연됨</li>
                    </ul>
                </ol>

                <h4>DNS란?</h4>
                Domain Name System. 도메인 이름과 IP 주소를 연결해 주는 시스템.

                <h4>클라이언트 동작 과정을 설명하세요.</h4>
                <ol>
                    <li>사용자가 브라우저 주소창에 https://www.example.com 입력</li>
                    <li>브라우저가 해당 URL의 DNS를 조회하고 서버 IP 주소 획득</li>
                    <li>서버에 HTTP GET 요청을 전송</li>
                    <li>서버로부터 HTML 문서와 관련 리소스를 응답받음</li>
                    <li>브라우저가 HTML, CSS, JavaScript를 해석하여 사용자 화면에 표시</li>
                    <li>사용작 버튼을 클릭하거나 입력을 추가하면 추가 요청을 서버로 전송송</li>
                </ol>

                <h4>서버 종류는 어떤 것이 있나요?</h4>
                <ul>
                    <li>웹 서버 : 주로 배포 단계에서</li>
                    <li>애플리케이션 서버: 동적 요청 처리; 예: 데이터베이스와 상호작용, API 호출, 주로 서비스 로직 개발에 사용</li>
                    <li>데이터베이스 서버</li>
                    <li>파일 서버 : 클라이언트에 파일을 저장하고 전송. 클라우드 기반 파일 서버가 주로 사용됨.</li>
                </ul>

                <h4>풀스택 개발자</h4>클라이언트와 서버의 구성 요소를 모두 개발할 수 있는 개발자

                <h4>클라이언트와 서버는 어떻게 다른가요?</h4>
                행사장 뒷편에서 물품을 나르는 역할을 하는건 서버.<br>행사장에서 참가자들 관리하는건 클라이언트

                <h4>블록체인의 노드와 웹 개발의 노드는 어떻게 다른가요?</h4>
                블록체인에서의 노드는 블록체인 네트워크에 연결된 컴퓨터를 말하며 여기서 노드는 데이터 저장, 검증 등을 한다.<br>
                웹 개발(Node.js)에서의 노드는 자바스크립트를 이용해 시스템을 만드는 서버이다.

                <h4>html에 대해 말해보세요.</h4>
                <ul>
                    <li>브라우저가 HTML 문서를 해석하고 렌더링 하는 기능을 가지고 있음.</li>
                    <li>Head - 속성; Body - 구조</li>
                    <li>Html 문서는 브라우저가 올바르게 해석할 수 있도록 .html 파일 확장자가 필요함.</li>
                </ul>

                <h4>CSS에 대해 말해보세요.</h4>
                <ul>
                    <li>Style 태그 안에 넣어야 함</li>
                    <li>선택자(selector)를 사용해 특정 HTML 요소에 스타일을 적용.</li>
                    <li>P { color: red; }</li>
                    <li>선택자Selector { 속성property: 속성값property value;}</li>
                    <li>박스모델: padding - border - margin</li>
                </ul>

                <h4>JavaScript에 대해 말해보세요.</h4>
                <ul>
                    <li>Script 태그 안에 넣어야 함</li>
                    <li>다양한 라이브러리(jQuery, Lodash) 및 프레임워크(React, Vue.js)와 함께 사용 가능</li>
                </ul>

                <h4>터미널 기반 텍스트 편집기를 사용해 내용 입력 후 저장하는 과정은?</h4>
                <li>% vim test.html</li>
                <li>I -> 내용 입력 -> ESC -> :wq (저장 후 종료)</li>

                <h4>코딩이란?</h4>명령어를 사용해 컴퓨터에 작업을 지시하는 과정. 이를 위해 코드 실행 가능한 런타임 환경에서 구동해야 함.

                <h4>VSCode에서 코드 자동 정렬 방법</h4>
                macOS: Shift + Option + F<br>
                혹은 마우스 우클릭 > “Format Document” 누르기

                주의 사항: VS Code 확장프로그램 Codeium: AI Coding Autocomplete!은 지금은 쓰지 말 것.

            </article>

            <article>
                <h3>Git</h3>
                <p>2025년 2월 11일</p>
                <h4>깃 워크플로우</h4>
                깃은 파일 상태 관리를 위해 다음 세 가지 영역을 사용:
                <ol>
                    <li>Working Directory: 로컬에서 작업중인 파일들이 위치하는 공간. 파일이 수정되면 Git이 추적하지만 아직 저장소에 반영되지 않은 상태</li>
                    <li>Staging Area: 커밋하기 위해 준비된 파일들이 임시로 저장된 공간. git add 명령으로 스테이징 영역에 추가</li>
                    <li>Repository: Git 이 관리하는 데이터베이스. git commit 명령으로 스테이징 영역의 파일이 저장소에 반영되고 변경 이력이 기록됨.</li>
                </ol>
                파일을 로컬에서 원결으로 깃허브에 올릴 때 쓰는 명령어는?
                <ol>
                    <li>git add (파일이름) 혹은 git add . : 마치 노드 멤풀에 트랜잭션이 모여있는 것과 같은 상태</li>
                    <ul>파일 상태는 Untracked(Git에서 관리하지 않는 파일) 또는 Modified(수정된 파일)로 표시됨</ul>
                    <ul>스테이징 영역에 추가</ul>
                    <li>git commit -m '메세지': 동료들이 내 메세지를 보고 어떤 작업을 했는지 파악할 수 있도록 메세지 작명</li>
                    <ul>변경사항을 로컬 저장소에 기록</ul>
                    <li>git push origin main: 여기서 origin은 이 코드가 원래 있어야 할 곳 (마스터 브랜치, 여기선 원격저장소); main은 브랜치</li>
                    <ul>원격 저장소에 업로드</ul>
                </ol>

                <h4>브랜치</h4>
                핵심 개념
                <ul>
                    <li>독립적인 작업 공간: 기존 코드에 영향을 주지 않고 새 작업 수행 가능</li>
                    <li>경량화된 포인터: Git에서 브랜치는 특정 커밋을 가리키는 포인터(참조); 새로운 커밋이 추가되면 브랜치는 자동으로 해당 커밋을 가리키도록 이동함</li>
                    <li>기본 브랜치와 병렬 브랜치: main과 master; feature와 fix</li>
                </ul>

                <p>브랜치끼리 충돌할 때 덮어쓰지 말기</p>
                다음 명령어 쓰기:<br>
                git pull origin main --no-rebase
                <ul>
                    <li>rebase: 우리 코드가 먼저다, 덮어 써라는 뜻</li>
                    <li>덮어쓰지 않도록 no rebase</li>
                </ul>
                <p>
                    브랜치 만들고 그 브랜치로 이동할 때 쓰는 명령어:<br>
                    git checkout -b 브랜치 이름
                </p>
                충돌 방지 위해 아래 습관화 하기 (출근 하자 마자 할 것):
                <ul>
                    <li>git fetch --all: 모든 원격 저장소 최신호</li>
                    <li>git pull origin main: 원격 저장소 origin의 main 브랜ㅇ치 코드 가져옴</li>
                </ul>
            </article>

            <article>
                <h3>HTML</h3>
                <p>2025년 2월 12일</p>

                <h4>HTML이란?</h4>
                <p>웹 페이지의 뼈대를 구성하는 마크업 언어.</p>

                <h4>HTML의 특징은?</h4>
                <ul>
                    <li>하이퍼텍스트: 문서간 연결</li>
                    <li>마크업 언어: 텍스트에 태그를 추가해 구조와 의미 정의</li>
                    <li>브라우저가 읽고 해석해 웹페이지로 렌더링</li>
                </ul>

                <h4>HTML의 구성요소는?</h4>
                <ol>
                    <li>!DOCTYPE html: 브라우저가 HTML5 규격에 맞게 콘텐츠 해석하도록 지정</li>
                    <li>html: HTML 문서의 루트요소로 모든 HTML 태그를 감쌈</li>
                    <li>head: 문서의 메타 정보 담음</li>
                    <li>body</li>
                </ol>

                <h4>속성(attribute)</h4>
                <p>태그에 추가 정보를 제공해 해당 요소의 동작이나 스타일을 설정하는 데 사용됨. <br>
                    속성명="값"의 형식으로 표현됨 </p>
                자주 사용하는 속성명
                <ul>
                    <li>id, class</li>
                    <li>href</li>
                    <li>src</li>
                    <li>alt</li>
                    <li>style</li>
                    <li>title</li>
                    <li>input</li>
                </ul>
                <a href="https://developer.mozilla.org/ko/docs/Web/HTML/Element">HTML 요소 참고서</a>
            </article>

            <article>
                <h4>SEO, 검색 엔진 최적화</h4>
                <p>검색 엔진에서 웹사이트가 더 높은 순위에 노출되도록 최적화하는 작업</p>
                <p>SEO 태그 사용의 중요성</p>
                <ul>
                    <li>검색 엔진에 정보 제공</li>
                    <li>검색 순위 향상</li>
                    <li>사용자 경험 개선</li>
                </ul>
            </article>

            <article>
                <h3>HTTL과 CSS는 어떻게 연결하나요?</h3>
                <p>Link 태그 또는 내부 스타일로 연결할 수 있습니다.</p>
                <ol>
                    <li>외부 스타일시트 연결: link rel="stylesheet” href=“css/styles.css”</li>
                    <li>내부 스타일시트: HTML 파일 안에서 style 태그를 사용</li>
                    <li>인라인 스타일: HTML 요소에 직접 스타일 정의</li>
                </ol>

                외부 스타일시트 연결할 때 주의 사항은?
                <ul>
                    <li>경로 설정</li>
                    <li>파일 확장자는 .css</li>
                    <li>스타일시트의 로딩 순서는 순서대로 로드됨
                    <li>
                </ul>

                <h4>CSS에서 ID와 Class는 각각 어떻게 쓰일까?</h4>
                <p>ID는 문서 내에서 유일해야 함. 한 요소에만 적용 가능</p>

                <h4>링크 스타일링 할 때 어떤 태그를 쓰나요?</h4>
                <p>a</p>

                <h4>Flexbox와 Grid에서 누구에게 속성을 주나요?</h4>
                <p>부모에게 속성을 주고, 부모가 자식들을 정렬한다.</p>

                <h4>미디어 쿼리란?</h4>
                <p>디바이스의 화면 크기, 해상도, 방향에 따라 다른 스타일을 적용할 수 있도록 도와줌. 이를 사용하면 반응형 웹 디자인(Responsive Web Design)을 구현할 수 있음.
                </p>
            </article>

            <article>
                <h3>Javascript (1) </h3>
                <p>2025년 2월 14일</p>
                <h4>자바스크립트에서 주석 다는 방법</h4>
                <p>// 다음에 작성, 혹은 /*, */ 사이에 작성</p>

                <h4>자바스크립트의 타입이란?</h4>
                <p>컴퓨터가 데이터를 어떻게 이해하고 처리할지를 나타내는 것. 같은 타입끼리 써야 함.</p>

                <h4>타입을 확인하는 방법은?</h4>
                <p>typeof라는 키워드 사용.
                    <br>console.log(typeof 42); // "number"
                    <br>console.log(typeof null); // "object"
                </p>

                <h4>Math 내장 객체의 대표적은 메서드는?</h4>
                <ul>
                    <li>Math.floor(): 괄호 안의 숫자를 내림하여 반환.</li>
                    <li>Math.ceil(): 괄호 안의 숫자를 올림하여 반환</li>
                    <li>Math.round(): 괄호 안의 숫자를 반올림 하여 반환.</li>
                </ul>
                문자열 주요 메서드: 지갑 주소 확인.비교할 때 유용함<br>
                논리 부정 연산자(!) 주로 언제 쓰이는지: 값이 없으면 오류를 내보내줘 할 때. 오류가 날 경우 다른 방식으로 할 수 있도록.<br>
                변수 : 재사용 가능<br>
                변수 선언 > 메모리에 공간 확보<br>
                할당 > 값을 메모리 공감에 저장<br>
                =는 저정한다는 뜻<br>
                템플릿 리터럴: 문자의 내부에 변수를 삽입할 수 있는 기능. 정말 많이 쓰임.<br>
                Return문: 터미널 출력이 안됨. </p>
            </article>

            <article>
                <h3></h3>
                <p></p>
                <h4></h4>
            </article>

            <article>
                <h3>Javascript (2)</h3>
                <p>2025년 2월 17일</p>
                <h4>조건문 if</h4>
                <p>동치연산자(===): 두 피연산자가 동일하면 true, 아니면 false를 반환함.<br>
                    !== 는 반대로 두 피연산자가 동일하지 않으면 true, 동일하면 false를 반환함.<br>
                    예: let name = 'bobLee'; <br>
                    if (name !== 'eliceKim') {console.log('가입할 수 있는 이름입니다.');}</p>
                <p>비교연산자(>, <,>-, <=)< /p>
                            <p>논리연산자(&&, ||): ||은 여러 조건 중 하나만 true 여도 true로 판단함. && 은 여러 조건 중 하나라도 false면 false로 판단.</p>
                            <p>부정연산자(!): 조건이 true이면 false, 조건이 false이면 true를 리턴함.</p>

                            <h3>삼항 조건 연산자</h3>
                            <p>if문과 else 문을 삼항 조건 연산자로 바꿔쓸 수 있음.<br>
                                예: let nim = 5; <br>
                                num % 2 === 0 ? console.log('짝수') : console.log('홀수'); </p>

                            <h3>반복문 for문</h3>
                            <p>for (초기값; 조건식; 증감식) { // 실행코드 }</p>
                            <p>예: 숫자 1부터 5까지의 수를 모두 더해라.<br>
                                let result = 0; <br>
                                for (let num = 1; num <=5; num++) { <br>
                                    result = result + num; <br> } <br><br>
                                    console.log(result); //15

                            </p>

                            <h3>문자열과 반복문</h3>
                            <p>예1: let str = 'rocketboost'; <br>
                                console.log(str[0]); // 'r' <br>
                                console.log(str[4]; // 'e' <br><br>

                                예2: let str = 'rocketboost';<br>
                                console.log(str.indexOf('c')); //2 <br>
                                console.log(str.indexOf('e')); //4</p>

                            <h3>반복문의 중첩</h3>
                            <p>반복문 내부에 또 다른 반복문을 사용할 수 있음. 단, 컴퓨터가 느려질 수 있음.</p>
                            <p>예: 이중반복문으로 구구단 전체를 출력하는 코드를 구현하세요. <br>
                                for (let i = 2; i <= 9; i++) {<br>
                                    console.log(`${1}단`);<br>
                                    for (let j = 1; j <= 9; j++) { <br>
                                        console.log(`${i} x ${j} = ${i * j}`); <br> } <br> }</p>

                            <h3>while문</h3>
                            <p>언제까지 반복할 지 모를 때 사용. 예를 들어 내 폴더 안에 몇 개의 파일이 있는지 모를 때.<br>
                                while문 작성할 때 조건식이 false로 평가되는 순간이 있는지 반드시 주의 (무한 루프 주의). <br>
                                do...while문: while 뒤에 오는 조건식이 true로 평가되는 동안 do 뒤에 오는 코드블록 내부의 코드를 반복해서 실행.</p>

            </article>

            <article>
                <h3>간단한 웹 애플리케이션 구현하기</h3>
                <P>2025년 2월 18일</P>
                의사코드(수도 코드): 실제로 코딩을 하기 전에 글로 작성한 논리. 마치 레서피와 같음. 의사코드 하는 습관 들이기.<br>

                ls에서 package.json이 나와야만 npm install 할 수 있음.<br>
                깃허브에 올릴 때 package-lack.json도 함께 올리는 것이 좋음. 왜냐하면 노드 버전도 다 이 안에 들어있어서 다른 사람이 사용된 버전 그대로 받을 수 있음.


            </article>

            <article>
                <h3>Javascript 3</h3>
                <p>배열과 객체 그리고 내장함수</p>
                배열은 순서대로 나열하고 싶을 때 사용. 예: 트랜잭션 처리.<br>
                객체는 구조화된 저장소. <br>
                함수는 공장처럼 인풋이 들어와서 어떤 과정을 거쳐 아웃풋이 나감.<br>

                <h4>참조 타입</h4>
                복접한 데이터를 나타내며 자바스크립트에서 객체, 배열, 함수 등을 포함함.
                이 데이터들은 값 자체가 아닌 메모리 주소(참조)를 저장하며, 여러 데이터를 묶어서 관리하거나 구조화할 때 사용됨.
                <p>특징:
                <ul>
                    <li>값이 아닌 메모리 주소 저장</li>
                    <li>하나의 객체를 여러 변수가 공유할 수 있음</li>
                    <li>복사하면 새로운 객체가 만들어지지 않고 같은 객체를 참조함</li>
                </ul>
                </p>

                <h4>얕은 복사와 깊은 복사</h4>
                <p>얕은 복사는 객체의 1단계 데이터만 복사. 중첩된 객체나 배열은 참조(주소)만 복사해서 복사본에 중첩 데이터를 수정하면 원본에도 영향을 미침.</p>
                <p>깊은 복사는 객체의 모든 데이터(중첩된 객체나 배열 포함)를 완전히 새로운
                    메모리 공간에 복사함. 복사본과 원본은 독립적이어서 한쪽을 수정해도 다른 쪽에 영향을 미치지 않음. 예: cloneDeep.
                </p>

                <h4>배열</h4>
                <p> 여러 데이터를 하나의 리스트로 묶어서 관리할 수 있는 데이터 타입.<br>
                    배열의 각 요소는 인덱스를 통해 접근할 수 있음.</p>
                <p>배열의 주요 메서드:
                <ul>
                    <li>push(): 배열의 끝에 요소 추가</li>
                    <li>unshift(): 배열의 앞에 요소 추가</li>
                    <li>for 루프 또는 forEach(): 배열의 각 요소 순회</li>
                    <li>filter(): 조건을 만족하는 요소만 필터링해 새 배열 생성</li>
                </ul>
                </p>

                <h4>배열의 반복</h4>
                <ul>
                    <li>for 루프: 배열의 길이를 기준으로 각 요소 처리.</li>
                    <li>for...of 루프: 배열의 요소에만 집중하는 간결한 반복문.</li>
                </ul>

                <h4>객체</h4>
                <p>키(key)-값(Value) 형태로 데이터 저장.<br>
                    객체 생성 방법:
                <ul>
                    <li>중괄호 { }롤 객체를 정의하는 객체 리터럴 방식. 예</li>
                    <li>Object 생성자</li>
                    <li>Object.create()</li>
                </ul>
                </p>

                <h4>객체 속성 접근</h4>
                <ul>
                    <li>점 표기법. 예: console.log(person.name);</li>
                    <li>대괄호 표기법. 예: console.log(person[key]);</li>
                </ul>

                <h4>객체의 주요 메서드</h4>
                <ul>
                    <li>Object.values()</li>
                    <li>Object.entries()</li>
                    <li>Object.assign()</li>
                </ul>

                <h4>객체와 반복</h4>
                <p>for...in 반복문: 객체의 속성을 순회할 때 사용.<br>
                    const person = { name: "철수", age: 30 };<br>
                    for (const key in person) {<br>
                    console.log(`${key}: ${person[key]}`);}<br>
                </p>

                <h4>기본 내장 함수</h4>
                배열, 문자열, 객체 등 양한 데이터 타입을 쉽게 다룰 수 있도록 자바스크립트에서 미리 제공하는 함수.<br>
                배열의 기본 내장 함수 예:
                <ul>
                    <li>indexOf(): 배열에서 특정 요소의 인덱스를 반환. 요소가 없으면 1 반환.</li>
                    <li>includes(): 배열에 특정 요소가 있는지 확인.</li>
                    <li>sort(): 배열의 요소 정렬.</li>
                    <li>slice: 배열의 일부 복사.</li>
                    <li>splice: 배열에서 특정 위치의 요소 제거/추가</li>
                </ul>

                <h4>객체의 내장 함수</h4>
                <ul>
                    <li>Object.keys(): 객체의 모든 키를 배열로 반환.</li>
                    <li>Object.hasOwnproperty(): 객체에 특정 키가 존재하는지 확인.</li>
                    <li>Object.freeze(): 객체를 동결해 수정할 수 없게 만듬. 새 속송 추가 혹은 기존 속성 변경 불가.</li>
                    <li>Object.seal(): 객체의 속성 추가 혹은 삭제 불가. 기존 속성 값은 수정 가능.</li>
                </ul>

                <h4>문자열의 내장 함수</h4>
                <ul>
                    <li>indexOf(): 문자열에서 특정 문자 또는 첫 번째 인덱스 반환</li>
                </ul>

            </article>

            <article>
                <h3>Javascript 4</h3>
                가제: 이렇게 코딩하면 안됩니다.
                <h4>원시 & 참조 타입</h4>
                <ol>
                    <li>값 자체를 저장 vs 주소값을 저장</li>
                    <li>원시 값 자체를 복사 vs 주소값을 복사</li>
                    <li>변경 불가능한 값 vs 변경이 가능한 값</li>
                </ol>

                <h4>스코프</h4>
                <p>일반적으로 스코프는 사격 시 목표물을 정확히 조준하기 위해 사용됨.<br>
                    자바스크립트에서의 스코프는 "변수의 유효범위"로 사용됨. <br>
                    바깥쪽 스코프에서 선언한 변수는 안쪽 스코프에서 사용 가능하지만
                    안쪽 스코프에서 선언한 변수는 바깥쪽 스코프에서 사용 불가능함.
                    (베그에서 안에 있음 밖이 보이지만 밖에선 안이 안 보이는 것과 비슷).
                </p>

                <h4>window 객체</h4>
                브라우저에만 존재하는 객체.
                함수 선언식으로 함수를 선언하거나 var로 선언된 전역 변수 및 전역 함수는 window 객체에 속하게 됨. <br>
                나중에 클라이언트 지갑, 메마 연결할 때 사용할 수 있음.

                <h4>권장 사항</h4>
                <ol>
                    <li>전역 변수는 최소화</li>
                    <ul>
                        <li>CSS 관심사 분리</li>
                    </ul>
                    <li>let, const 사용</li>
                    <ul>
                        <li>var는 블록 스코프를 무시함. 또한 같은 이름의 변수를 재선언 해도 에러를 내지 않음.
                        </li>
                    </ul>
                    <li>선언 없는 변수 할당 금지</li>
                    <li>실수 방지 위해 Strict Mode 사용</li>
                </ol>

                <h4>클로져</h4>
                함수 안쪽에서 바깥쪽의 변수를 사용할 수 있지만 그 반대는 안된다는 것. <br>
                외변접내: 외부 함수의 변수에 접근할 수 있는 내부 함수 <br>
                <br>클로저가 중요한 이유: <br>
                클로저의 함수는 어디에서 호출되느냐와 무관하게 선언된 함수 주변 환경에 따라 접근할 수 있는 변수가 정해짐.

                <h4>클로저의 특징을 활용한 사례</h4>
                <ul>
                    <li>데이터를 보존하는 함수</li>
                    <ul>아래 코드에서 getFoodRecipe가 클로저로서
                        foodName, ingredient1, ingredient2에 접근할 수 있음. <br>
                        이 때 createFoodRecipe('하이볼')으로 전달된 문자열 '하이볼'은 recipe 함수 호출 시 계속 재사용할 수 있음.<br>
                        <br> function createFoodRecipe (foodName) {
                        <ul>let ingredient1 = '탄산수';</ul>
                        <ul>let ingredient2 = '위스키';</ul>
                        <ul>const getFoodRecipe = function () {</ul>
                        <ul>return `${ingredient1} + ${ingredient2} = ${foodName}!`;}</ul>
                        <ul>return getFoodRecipe</ul>
                        <br>
                        <ul> const recipe = createFoodRecipe('하이볼');</ul>
                        <ul>recipe(); // '탄산수 + 위스키 = 하이볼!'</ul><br>
                    </ul>
                    <li>커링</li>
                    <ul>
                        <li>여러 전달인자를 가진 함수를 함수를 연속적으로 리턴하는 함수로 변경하는 행위</li>
                        <ul>function sum(a, b) {return a + b;}</ul><br>
                        <ul>function currySum(a)
                            <ul>{return function (b) {
                                <ul>return a + b; }; }</ul>
                            </ul>
                        </ul><br>
                        <ul>console.log(sum(10,20) === currySum(10)(20))</ul>
                    </ul>
                    <ul>
                        <li>전체 프로세스의 일정 부분까지 실행하는 경우 유용 </li>
                    </ul><br>
                    <li>모듈 패턴
                        <ul>
                            <li>모듈은 하나의 기능을 온전히 수행하기 위한
                                모든 코드를 가지고 있는 코드 모음으로 하나의 단위로서 역할을 함.
                            </li>
                        </ul>
                    </li>
                </ul>
                <p>클로저는 특정 데이터를 다른 코드의 실행으로부터 보호해야할 때 용이하다.</p>

                <h4>spread/rest 문법</h4>
                <ul>
                    <li>spread 문법
                        <ul>
                            <li>배열을 풀어서 인자로 전달하거나, 배열을 풀어서 각각의 요소로 넣을 때 사용</li>
                        </ul>
                        <ul>function sum(x, y, z) {<br>
                            <ul>return x + y + z; } </ul><br>
                            <ul>const numbers = [1, 2, 3];</ul>
                            <ul>sum(...numbers) //6</ul>
                        </ul>

                    </li>
                    <li>rest 문법
                        <ul>
                            <li>파라미터를 배열의 형태로 받아서 사용할 수 있음.</li>
                            <ul>function sum(...theArgs) {
                                <ul>return theArgs.reduce((previous, current) => {
                                    <ul>return previous + current; }); }</ul>
                                </ul>
                            </ul><br>
                            <ul>sum(1,2,2) ///6</ul>
                        </ul>
                    </li>
                </ul>

                <h4>화살표 함수</h4>
                <p>함수를 정의하는 방법:
                <ul>
                    <li>함수 선언문
                        <ul>function sum (x, y) { </ul>
                        <ul>return x + y; }</ul>
                    </li>
                    <li>함수 표현식
                        <ul>const subtract = function (x, y) {</ul>
                        <ul>return x - y; }</ul>
                    </li>
                </ul>
                </p>
                <p>여기에 더해 화살표 함수가 있음. function 키워드 대신 화살표(=>)를 사용함.
                <ul>const multiply = (x, y) => {</ul>
                <ul>return x * y; }</ul>
                매개변수가 한 개일 때 소괄호 생략 가능.<br>
                함수 코드 블록 내부가 하나의 문으로 구성되어 있다면 중괄호 생략 가능.
                </p>
            </article>


            <article>
                <h3>DOM</h3>
                <p>Document Object Model. HTML 요소를 Object처럼 조작할 수 있는 모델.</p>
                <p>아래는 HTML 파일과 같은 디렉토리에 존재하는 myScriptFile.js를 불러옴.<br>
                <pre><code>src="myScriptFile.js</pre></code>
                </p>
                <p>script 코드는 body가 끝나기 전에 넣기</p><br>
                <p>CREATE, APPEND, READ를 통해 새로운 DOM 객체를 만들고, 기존의 DOM 객체에 붙이고, DOM 객체를 선택해서 조회할 수 있음.</p>
                <p>READ, UPDATE, DELETE</p>

                <h4>여러 개의 자식 요소 지우기</h4>
                <p>innerHTML로 모든 자식 요소 지울 수 있지만, 보안 문제가 있음.<br>
                    removeChild는 자식 요소를 지정해 삭제하는 메서드. for, while 반복문을 활용해 자식 요소가 남아있지 않을 때까지 모든 자식 요소 삭제할 수 있음.</p>
            </article>


            <article>
                <h3 style="color:darkmagenta">2025 최신 탈중앙화 애플리케이션(DApp) 동향</h3>
                <p style="font-style: italic;">다음 보고서는 전 세계에서 가장 성과가 뛰어난 탈중앙화 애플리케이션(DApp)을 추적하는 DappRadar의 최신 순위를 기반으로,
                    OpenAI의 ChatGPT 인사이트를 활용하여 작성되었습니다.</p>
                <h4>소개</h4>
                <p>탈중앙화 애플리케이션(DApp)은 금융, 게임, 메타버스, 소셜 플랫폼 등 다양한 분야에서 블록체인 생태계를 변화시키고 있습니다. DappRadar의 최신 순위를 바탕으로, 현재
                    DeFi(탈중앙화 금융), 크로스체인 상호운용성, 메타버스, NFT, 탈중앙화 소셜 플랫폼이 강세를 보이고 있습니다. 아래는 전 세계 상위 10대 DApp을 분석한 최신
                    트렌드입니다.</p>
                <h4>DApp 생태계 주요 트렌드</h4>
                <ol>
                    <li>차세대 DeFi 플랫폼의 부상</li>
                    <ul>
                        <li>KAI-CHING, Jupiter Exchange, Radium과 같은 상위 DApp들은 탈중앙화 금융 서비스에 대한 지속적인 높은 수요를 보여줍니다.</li>
                        <li> 이유? 사용자들은 전통적인 은행 시스템의 대안으로 스테이킹, 대출, 차입, 크로스체인 거래를 제공하는 DeFi 플랫폼을 선호합니다.</li>
                        <li>향후 전망: 실물 자산(RWA)과의 통합, AI 기반 거래, 기관 투자자들의 DeFi 솔루션 도입이 가속화될 것입니다.</li>
                    </ul>
                    <li>크로스체인 상호운용성의 확산</li>
                    <ul>
                        <li>HOT Protocol과 Particle Network는 블록체인 간의 원활한 상호작용을 가능하게 하는 크로스체인 솔루션의 성장세를 보여줍니다.</li>
                        <li>이유? 더 많은 사용자와 개발자가 낮은 가스비와 높은 효율성을 제공하는 멀티체인 거래를 원하고 있습니다.</li>
                        <li>향후 전망: 크로스체인 브릿지, 레이어 2 확장 솔루션, 멀티체인 DeFi 플랫폼이 시장을 주도할 것입니다.</li>
                    </ul>
                    <li>메타버스 및 블록체인 게임의 지속적인 성장</li>
                    <ul>
                        <li>World of Dypians, Age of Dino, Pixels는 메타버스 게임과 NFT 기반 경제에 대한 지속적인 관심을 반영합니다.</li>
                        <li>사용자들은 디지털 자산의 소유권, 플레이투언(P2E) 인센티브, 몰입형 경험을 원합니다.</li>
                        <li>향후 전망: P2E에서 ‘플레이 앤 언(Play-and-Earn)’ 모델로 전환하여 게임성이 수익만큼 중요해질 것입니다. 또한 AI 및 AR/VR과의 통합이 더욱
                            심화될 것입니다.</li>
                    </ul>
                    <li>탈중앙화 소셜 미디어와 콘텐츠 수익화의 부상</li>
                    <ul>
                        <li>LOL과 UXUY는 Web3 소셜 플랫폼의 성장세를 보여줍니다.</li>
                        <li>이유: 사용자들은 자신의 콘텐츠에 대한 더 많은 통제권, 데이터 프라이버시 보호, 수익 창출 기회를 요구하고 있습니다.</li>
                        <li>향후 전망: 토큰화된 참여 모델, 탈중앙화 신원(DID), AI 기반 콘텐츠 큐레이션이 사용자 경험을 향상시킬 것입니다.</li>
                    </ul>
                </ol>

                <h4>상위 10대 DApp 개요</h4>
                <ol>
                    <li>KAI-CHING (DeFi)</li>
                    <ul>
                        <li>스테이킹, 대출, 차입 서비스를 제공하는 저수수료·고보안 DeFi 플랫폼</li>
                    </ul>
                    <li>HOT Protocol (크로스체인)</li>
                    <ul>
                        <li>멀티체인 거래를 효율적으로 지원하는 크로스체인 유동성 프로토콜</li>
                    </ul>
                    <li>World of Dypians (메타버스)</li>
                    <ul>
                        <li>NFT와 탈중앙화 금융을 결합한 메타버스 게임 플랫폼</li>
                    </ul>
                    <li>Radium (탈중앙화 거래소)</li>
                    <ul>
                        <li>빠르고 안전하며 저수수료의 암호화폐 거래를 제공하는 DEX</li>
                    </ul>
                    <li>Particle Network (탈중앙화 클라우드)</li>
                    <ul>
                        <li>유휴 컴퓨팅 파워를 활용하는 탈중앙화 클라우드 컴퓨팅 네트워크</li>
                    </ul>
                    <li>LOL (탈중앙화 소셜 미디어)</li>
                    <ul>
                        <li>콘텐츠 제작과 큐레이션을 통해 사용자에게 보상을 제공하는 Web3 소셜 플랫폼</li>
                    </ul>
                    <li>UXUY (블록체인 UX 개선)</li>
                    <ul>
                        <li>블록체인 애플리케이션의 UX를 개선하는 도구 세트</li>
                    </ul>
                    <li>Jupiter Exchange (DeFi)</li>
                    <ul>
                        <li>높은 유동성을 갖춘 경쟁력 있는 DeFi 거래 플랫폼</li>
                    </ul>
                    <li> Age of Dino (NFT 게임)</li>
                    <ul>
                        <li>공룡 테마의 NFT 기반 게임으로 번식 및 배틀 기능 포함</li>
                    </ul>
                    <li>Pixels (탈중앙화 아트 플랫폼)</li>
                    <ul>
                        <li>예술가들이 디지털 창작물을 수익화할 수 있는 블록체인 기반 아트 플랫폼</li>
                    </ul>
                </ol>

                <h4>결론: DApp의 미래 전망</h4>
                <p>차세대 DApp은 다음에 초점을 맞출 것입니다:</p>
                <ul>
                    <li>확장성: 레이어 2 및 크로스체인 솔루션을 통한 빠른 거래</li>
                    <li> 사용자 경험(UX): 주류 사용자 유입을 위한 온보딩 및 접근성 개선</li>
                    <li>AI 및 자동화: AI 기반 스마트 컨트랙트, 트레이딩 봇, 자동화된 DeFi 전략</li>
                    <li>실제 활용 사례: 금융, 신원 인증, 게임 등 실생활과 연결된 DApp 증가</li>
                </ul>
                DApp은 투기적 요소를 넘어 실생활에 적용되는 단계로 진화하고 있습니다. 금융, 게임, 메타버스, 소셜 미디어 등 다양한 분야에서 효율성, 사용성, 금융적 자유를 중시하는 Web3
                애플리케이션이 더욱 발전할 것입니다.
                <p>DApp의 미래는 이미 시작되었습니다 – 더 탈중앙화되고, 효율적이며, 사용자 중심적인 방식으로!</p>
            </article>

            <article>
                <h3>Javascript 5</h3>
                <h4>고차함수</h4>
                <ul>
                    <li>함수를 전달인자(arguemnt)로 받을 수 있고,함수를 리턴할 수 있는 함수</li>
                    <li>콜백 함수: 다른 함수의 전달인자로 전달되는 함수</li>
                    <li>요리 레시피와 비슷함</li>
                    <li>모듈 개발 할 때 많이 쓰임</li>
                    <li>내장 함수를 잘 쓰기 위해 필요</li>
                </ul>

                <h4>내장 함수 특징</h4>
                <ul>
                    <li>for문보다 성능이 뛰어남</li>
                    <li>코드가 간결해짐</li>
                    <li>재사용이 가능함</li>
                </ul>

                <h4>내장 고차 함수</h4>
                <ul>
                    <li>filter, reduce, map은 자주 사용됨</li>
                    <li>reduce는 배열의 모든 값을 '누적해서' 결과를 도출하는 내장함수</li>
                    <li>맵핑은 마치 월요일에는 다섯 쌍둥이 모두 빨간색으로 입히기로 하는 것처럼 각 요소에 똑같이 적용하는 것</li>
                    <li>예: 네이버 메인 화면에서 상품 그림 구성된것은 프론트 앤드 개발자가 객체에 담긴 데이터를 맵핑한 것</li>
                </ul>

                <h4>reduce의 여러 인자</h4>
                <ul>
                    <li>callback 함수</li>
                    <li>accumulator: 누산기(계산이 누적된 값)</li>
                    <li>currentValue: 현재 처리중인 요소의 값</li>
                    <li>currentIndex: 현재 처리중인 인텍스의 값</li>
                    <li>array: reduce를 호출한 배열</li>
                    <li>초기값</li>
                </ul>

                <h4>filter 예시</h4>
                <p>배열에서 keeper와 일치하는 요소만을 갖는 새로운 배열을 리턴해라 <br>
                    <br>function keep(arr.keeper) {<br>
                <ul>return arr.filter(element => element === keeper);} </ul>
                </p>

                <h4>reduce 예시</h4>
                <p>number 타입을 요소로 갖는 배열을 입력받아 배열의 모든 요소의 합을 리턴해라 <br>
                    <br>function computeSumOfAllElements(arr) {
                <ul>if (arr.length === 0) {
                    <ul>return 0;}</ul><br>
                    return arr.reduce((sum, current) => sum + current, 0);}
                </ul> <br>
                const coinWallet = [10, 50, 100, 500]; <br>
                <br>const vault = 660; <br>
                <br>const reduceVault = coinWallet.reduce((acc, cur, idx, arr) => {
                <ul>console.log(`acc: ${acc}, cur: ${cur}, idx: ${idx}, arr: ${arr}`);</ul>
                <ul>return acc + cur;</ul>
                }, 10);<br>
                <br>console.log(reduceVault);


                </p>

                <h4>map 예시</h4>
                <p>배열의 각 요소를 2배 곱한 새로운 배열을 리턴해라 <br>
                    <br>function getDoubledElements(arr) {<br>
                <ul>return arr.map(number => number*2);}</ul>
                </p>

                <h4>reduce의 여러 인자</h4>
                - callback 함수
                - accumulator: 누산기(계산이 누적된 값)
                - currentValue: 현재 처리중인 요소의 값
                - currentIndex: 현재 처리중인 인텍스의 값
                - array: reduce를 호출한 배열
                - 초기값


                <h4>고차함수의 중요성</h4>
                <ul>
                    <li>추상화 = 생산성의 향상</li>
                    <li>추상화: 복잡한 어떤 것을 압축해서 핵심만 추출한 상태로 만드는 것</li>

                </ul>

            </article>

            <article>
                <h3>객체 지향 프로그래밍(OOP)</h3>
                <p> 사람이 세계를 보고 이해하는 방법과 매우 흡사.<br>
                    자바스크립트 사용하는 사람들이 이렇게 하는게 어떨까? 해서 만들어짐.</p>
                <h4>객체 지향 프로그램이란</h4>
                하나의 모델이 되는 청사진을 만들고, => class<br>
                그 청사진을 바탕으로 한 객체(object)를 만드는 => instance<br>
                프로그래밍 패턴

                <h4>구조</h4>
                <p style="font-style: italic">구조 익히기. 나중에 배울 솔리디티와 비슷.</p>
                <p>
                <pre><code>
                        class Car {constructor(brand, name, color) { <br>
                        // 인스턴스가 만들어질 때 실행되는 코드 } } </code></pre><br>
                constructor라는 함수가 인자를 받고 초기 세팅으로 처음 딱 한 번 실행됨. const로 변수 선언 안 해도 됨.</p>
                <p>new 키워드를 통해 클래스의 인스턴스를 만들어낼 수 있음.<br>
                <pre><code>
                        let avante = new Car('hyundai', 'avante', 'black');
                        let mini = new Car('bmw', 'mini', 'white');
                    </code></pre>
                여기서 avante가 인스턴스. 각 인스턴스는 Car 라는 클래스의 고유한 속성과 메서드를 가짐.
                </p>

                <h4>속성과 메서드</h4>
                예를 들어 자동차의 속성은 브랜드, 차 이름, 색상, 현재 연료 상태, 최고 속력 등이 있음.<br>
                메서드는 연료 주입, 속력 설정, 운전 등 자동차의 기능을 말함. 쉽게 말해 메서드는 객체에 딸린 함수임 (function이 따로 필요 없음).

                <h4 style="color:#ff4d94">OOP 주요 개념</h4>
                <ul>
                    <li>캡슐화 - 필요한 정보만 보여주는 것 </li>
                    <ul>
                        <li>데이터(속성)과 기능(메서드)을 하나의 객체 안에 넣어서 묶는 것. 즉 데이터와 기능이 느슨하게 결합되는 것.</li>
                        <li>느슨한 결합은 코드 실행 순서에 따라 절차적으로 코드를 작성하는 것이 아니라, 코드가 상징하는 실제 모습과 닮게 코드를 모아 결합하는 것을 의미함.</li>
                        <li>예: 마우스 구동. 마우스 상태를 '속성'으로 정하고 클릭, 이동을 '메서드'로 정하는 것.</li>
                        <li>구현은 숨기고 동작은 노출시키는 은닉화 특징도 포함.</li>
                        <li>언제든 구현을 수정할 수 있어 느슨한 결합에 유리</li>
                    </ul>
                    <li>추상화 - 복잡한 것은 감추고 필요한 것만 제공</li>
                    <ul>
                        <li>내부 구현은 아주 복잡한데 실제로 노출되는 부분은 단순하게 만든다는 개념.</li>
                        <li>추상화를 통해 인터페이스가 단순해짐.</li>
                        <li>예: 전화기</li>
                        <li>캡슐화가 코드나 데이터의 은닉에 포커스가 맞춰져있다면,
                            추상화는 클래스를 사용하는 사람이 필요하지 않은 메서드 등을 노출시키지 않고 단순한 이름으로 정의하는 것에 포커스가 맞춰져 있음.</li>
                    </ul>
                    <li>상속 - 재사용</li>
                    <ul>
                        <li>부모 클래스 특징을 자식 클래스가 물려받는 것.</li>
                    </ul>
                    <li>다형성- 같은 동작, 다른 결과</li>
                    <ul>
                        <li>짖어봐! 하면 꽥! 멍멍! 야옹! 하는 것.</li>
                    </ul>
                </ul>
                <p>한 마디로 캡슐화는 숨기고, 추상화는 단순화하고, 상속은 물려주고, 다형성은 다르게 동작하는 것.<br>
                    결국 OOP는 사람이 세계를 보고 이해하는 방법을 흉내낸 방법론.<br>
                    OOP의 특성을 이해하고 잘 사용하면 좋은 설계 할 수 있음.</p>

                <h4>객체 지향 언어들의 차이점</h4>
                <p style="font-style: italic;">
                    자바스크립트는 프로토타입 기반 언어이고 객체지향 언어로 쓰기 어렵다.
                </p>
                <ul>
                    <li>은닉화(private 키워드)의 한계</li>
                    <li>추상화(interface 키워드) 기능의 부재</li>
                </ul>
            </article>

            <article>
                <h3>심화 - 비동기</h3>
                <p>Node.js는 논블로킹(non-blocking)하고 비동기적(asynchronous)으로 작동하는 런타임으로 개발됨.<br>
                    JavaScript는 기본적으로 동기적으로 코드가 실행되지만 JavaScript 엔진(예: V8)과 브라우저 또는 Node.js와 같은 런타임 환경이 함께 협력하여 비동기 작업을
                    처리함.
                <ul>
                    <li>비동기 코드는 코드가 작성된 순서대로 작동되는 것이 아니라 동작이 완료되는 순서대로 작동하게 됨. 개발자는 예측 가능한 코드를 작성하도록 노력해야 함.</li>
                </ul>
                </p>

                <h3>비동기로 작동하는 코드 제어하는 방법 1 - 콜백</h3>
                <p>함수를 통해 비동기 코드의 순소를 제어할 수 있다. 코드가 길어질수록 복잡해지고 가독성이 낮아지는 Callback Hell이 발생하는 단점이 있다.
                <ul>const printAll = () => {
                    <ul>printString('A', () => {
                        <ul>printString('B', () => {
                            <ul> printString('C', () => {})"</ul>
                        </ul>
                    </ul>
                </ul>
                </p>

                <h3>비동기로 작동하는 코드 제어하는 방법 2 - Promise</h3>
                <p>Promise는 class이기 때문에 new 키워드를 통해 Promise 객체를 생성함.<br>
                    Promise는 비동기 처리를 수행할 콜백 함수(executor)를 인수로 전달받는데, 이 콜백 함수는 resolve, reject 함수를 인수로 전달 받음. <br>
                    pROMISE 객체가 생성되면 executor는 자동으로 실행되고 작성했던 코드들이 작동됨.<br>
                    코드가 정상적으로 처리 되면 resolve 함수를 호출, 에러가 발생하면 reject 함수를 호출.
                <ul>let promise = new Promise((resolve, reject) => { <br>
                    정상적으로 처리되는 경우 resolve 인자에 값을 전달할 수 있다 <br>
                    resolve(value); <br>
                    에러가 발생하면 reject 인자에 에러 메세지를 전달할 수 있다 <br>
                    reject(error); <br>
                    });</ul>
                </p>

                <h3>Promise 객체의 내부 프로퍼티</h3>
                <p>new Promise가 반환하는 Promise 객체는 state, result 내부 프로퍼티를 갖고있음. .then, .catch, .finally의 메서드를 사용해 접근 가능.
                    <br>
                    State: 기본 상태(state)는 pending 이다. 콜백함수(executor)가 성공적으로 작동하면 fulfilled로, 에러가 발생하면 rejected가 됨.<br>
                    Result: 처음은 undefined이다. 콜백함수(executor)가 성공적으로 작동하여 resolve(value)가 호출되면 value로, 에러가 발생하여
                    reject(error)가 호출되면 error로 변함.
                </p>

                <p style="font-weight: 900;">then, catch, finally</p>
                <p>Then: executor에 작성했던 코드들이 정상적으로 처리되면 resolve 함수를 호출하고 .then 메서드로 접근할 수 있다. <br>
                    .then 안에서 리턴한 값이 Promise면 Promise의 내부 프로퍼티 result를 다음 .then의 콜백함수의 인자로 받아오고, <br>
                    Promise가 아니라면 리턴한 값을 .then의 콜백 함수의 인자로 받아올 수 있다.</p>

                <p style="font-weight: bold;">Promise chaining</p>
                <p>비동기 작업을 순차적으로 진행해야 하는 경우 필요함. </p>

                <h3>비동기로 작동하는 코드 제어하는 방법 2 - Promise.all()</h3>
                <p>여러 개의 비동기 작업을 동시에 처리하고 싶을 때 사용. 인자로 배열을 받고, executor내 작성했던 코드들이 정상적으로 처리되면 결과를 배열에 저장해 새로운 Promise를
                    반환함
                <ul>Promise.all([promiseOne(), promiseTwo(), promiseThree()])
                    <ul>.then(value) => console.log(value))<br>
                        .catch((err) => console.log(err));</ul>
                </ul>
                인자로 받는 배열에 있는 Promise 중 하나라도 에러가 발생하면 나머지 Promise의 state와 상관없이 즉시 종료됨. </p>

                <h3>Async/Await</h3>
                <p>async/await 키워드로 복잡한 Promise 코드를 간결하게 작성할 수 있다. <br>
                    함수 앞에 async 키워드를 사용하고 async 함수 내에서만 await 키워드 사용. <br>
                    await 키워드가 작성된 코드가 동작하고 나서야 다음 순서의 코드가 동작함.</p>

                <h3>Node.js</h3>
                <p>비동기 이벤트 기반 JavaScript 런타임.<br>
                    JavaScript를 사용하여 서버 사이드 애플리케이션을 개발할 수 있게 해주는 런타임 환경.<br>
                    기존에 JavaScript가 브라우저에서만 실행되던 것과 달리 서버측에서도 Javascript를 실행할 수 있도록 해줌.</p>

                <h3>Node.js 내장 모듈을 사용하는 방법</h3>
                <p>모듈이란? 건축에서 온 단어로 어떤 기능을 조립할 수 있는 형태로 만든 부분이란 뜻. <br>
                    그중 fs(FileSystem) 모듈은 PC의 파일을 읽거나 저장하는 등의 일을 할 수 있게 도와줌.</p>
                <p>Node.js 내장 모듈 목록은 다음 링크에서 찾을 수 있다:
                    <a href="https://nodejs.org/docs/latest-v18.x/api/index.html">Node.js v18.20.6 Documentation</a>
                </p>
                <p>
                    모든 모듈은 모듈을 사용하기 위해 불러오는 과정이 필요함.<br>
                    브라우저에서 다른 파일을 불러올 때는: 스크립트 src=...<br>
                    <br> Node.js는 자바스크립트 코드 가장 상단에 require 구문을 이용해 다른 파일을 부른다.
                <ul>
                    <li>const fs = require('fs'); // 파일 시스템 모듈을 불러옵니다</li>
                </ul>
                </p>
                <p>3rd-party 모듈 사용 방법<br>
                    외부 모듈. 예를 들어 Node.js공식 문서에 없는 underscore 모듈을 설치하려면: npm install underscore<br>
                    require 구문으로 불러오기: const _ = require('underscore');</p>

                <h3>fs.readFile을 통해 알아보는 Node.js 공식문서 가이드</h3>

                <h3>fetch API</h3>
                <p>특정 URL로부터 정보를 받아오는 역할을 함.</p>

                <h3>Axios</h3>
                <p>Node.js를 위한 Promise API를 활용하는 HTTP 비동기 통신 라이브러리.<br>
                    Fetch API보다 사용이 간편하면서 추가적 기능이 포함되어 있음.<br>
                    자동으로 JSON데이터 형식으로 변환됨 (Fetch API는 .json()메서드를 사용해야 함)</p>

            </article>


            <article>
                <h3>리액트 기초</h3>
                <ul>
                    <li>자바스크립트 프레임워크로 UI 구축 위해 사용됨</li>
                    <li>특히 단일 페이지 애플리케이션(SPA) 만들 때 유용</li>
                    <li>데이트 변경 시 효율적으로 UI 업데이트 하는데 강점</li>
                    <li>컴포넌트 기반(구조 자체 클러스터링 가능); 가상 DOM; 풍부한 생태계(오픈소스)
                        <ul>
                            <li>신입 때는 공용 컴포넌트 만지지 말기.</li>
                        </ul>
                    </li>
                </ul>

                <p>리액트를 사용하는 이유는?
                <ul>
                    <li>SPA(Single Page Application) 지원: 유튜브처럼 페이지 전환 없이 동적으로 콘텐츠 업데이트 가능</li>
                    <li>커뮤니티 지원</li>
                    <li>유연성: 다른 라이브러리나 프레임워크와 쉽게 통합할 수 있음. ex: Recoil 상태 관리 라이브러리.</li>
                </ul>
                </p>

                <h4>JSX</h4>
                <p>JavaScript XML <br>
                    JSX란? 자바스크립트로 HTML 문법을 사용하는 것. <br>
                    리액트에서는 JSX를 사용해 컴포넌트의 구조를 직관적으로 표현할 수 있음.
                <ul>
                    <li>JSX는 HTML처럼 보이지만 실제로는 자바스크립트로 변환됨 (HTML과 달리 class 대신 className을 사용)</li>
                    <li>{} 안의 값을 동적으로 변화시킬 수 있음</li>
                </ul>
                </p>

                <h4>컴포넌트</h4>
                <p style="font-weight: bold;">함수형 컴포넌트</p>
                <p>간단한 함수로 정의되며 Hooks를 사용해 상태 관리</p>
                <ul>function Welcome() {<br>
                    <ul>return < h1>Hello, React!< / h1>;} </ul>
                </ul>
                <ul>
                    <li>함수 이름은 대문자로 시작해야 함</li>
                    <li>상태: 컴퓨터가 어떤 값을 기억하는 것. DB에 저장되는 것은 아님.</li>
                    <li>Hooks: 리액트에서 기억하고 저장할 때 도와주는 도구들</li>
                </ul>

                <p style="font-weight: bold;">클래스형 컴포넌트</p>
                클래스로 정의되며 생명주기 메서드를 사용할 수 있다.
                <ul>class Welcome extends React.Component {<br>
                    <ul>render() {<br>
                        <ul>return < h1>Hello, React!< / h1>; } }</ul>
                    </ul>
                </ul>
                <br>
                <p style="font-style: italic;">어떤 방식을 쓰는지는 회사마다 다를 것</p>


                <h4>Props와 State</h4>
                <p style="font-weight: bold;">Props</p>
                <p>부모 컴포넌트에서 자식 컴포넌트로 데이터 전달할 때 사용. 키워드가 아님.</p>
                <ul>function Welcome(props) {<br>
                    <ul>return < h1>Hello, {props.name}!< / h1>; }</ul>
                </ul><br>
                <ul>function App() { <br>
                    <ul>return
                        <"Welcome name="React" />; }
                    </ul>
                </ul>

                <p style="font-weight: bold;">State</p>
                <p>컴포넌트 내부에서 관리되는 상태. 상태가 변경되면 컴포넌트가 다시 렌더링됨<br>
                    스테이트는 컴퓨터가 기억하는 값이고 { } 안에는 변수 쓸 수 있음.</p>
                <p style="font-style: italic;">선생님은 이 문법을 외우셨음.</p>

                <p style="font-style: italic;">Props는 외부에서 전달되며 읽기 전용이다.
                    State는 컴포넌트 내부에서 관리되며 변경 가능하다.
                </p>

                <p>이벤트 핸들러를 통해 State 업데이트 가능</p>

            </article>


            <article>
                <h4>JSX(Javascript XML)</h4>
                <p>JavaScript로 HTML 문법을 사용한다고 이해하기 </p>
                <p>React에서 UI를 구성할 때 사용하는 문법으로 JavaScript를 확장한 문법. 이 문법을 통해 React 엘리먼트를 만들 수 있다.<br>
                    Babel은 JSX를 브라우저가 이해할 수 있는 JavaScript로 컴파일한다.<br>
                    JSX 규칙
                <ul>
                    <li>하나의 엘리먼트 안에 모든 엘리먼트가 포함</li>
                    <li>CSS class 속성을 지정하려면 "className"으로 표기(만약 class로 작성하면 React에서 이를 html속성 대신 자바스크립트 클래스로 받아들임)</li>
                    <li>중괄호{ } 이용</li>
                    <li>사용자 정의 컴포넌트는 대문자로 시작. 예: function Hello()</li>
                    <li>조건부 렌더링에 삼항연사자 사용</li>
                    <li>여러 개의 HTML 엘리먼트를 표시할 때 map() 함수 이용
                        <ul>
                            <li>반드시 "key" JSX 속성을 넣어햐 함</li>
                        </ul>
                    </li>
                </ul>
                </p>

                <h4>Component로 생각하기기</h4>
                <p>
                    <ul><li>하나의 기능을 구현하기 위한 여러 종류의 코드 묶음; UI를 구성하는 필수 요소</li>
                    <li>root 컴포넌트는 자식 컴포넌트를 가질 수 있고 이 계층적 구조(hierarchy)를 트리 구조로 형상화 할 수 있다</li>
                    <li>function 이름은 대문자로 시작</li>
                    <li>함수형 쓸지 클래스형 쓸지는 회사마다 다를 것 </li>
                </ul>
                </p>

            </article>


            <article>
                <h3>심화 - ReactSPA</h3>
                <p>SPA(Simple Page Application): 페이지 갱신에 필요한 데이터만 받아 업데이트 함으로써 사용자와 소통하는 웹 어플리케이션이나 웹사이트 </p>
                <p>HTML 문서 전체가 아니라 업데이트가 필요한 데이터만 받아 JavaScript가 이 데이터를 조작하여 HTML 요소를 생성하여 화면에 보여주는 방식
                </p>

                <h4>SPA 단점</h4>
                <ol>
                    <li>긴 로딩 시간
                        <ul>
                            <li>첫 로딩 시 JavaScript 파일을 기다리는 시간 때문에</li>
                        </ul>
                    </li>
                    <li>부족한 검색 엔진 최적화</li>
                </ol>

                <h4>Wireframe & Mockup</h4>
                <ul>
                    <li>Wireframe: 디자인 들어가기 전 단계로 선으로 윤곽선을 잡는 것</li>
                    <li>Mockup: 데스크톱, 스마트폰의 프레임을 덧씌워 직관적으로 이해하기 쉽게 디자인한 것</li>
                </ul>

                <h4>React Router</h4>
                <p>리액트 애플리케이션에서 클라이언트 사이드 라우팅을 구현하기 위해 사용되는 가장 인기 있는 라이브러리<br>
                    SPA에서 페이지 전환 없이 URL에 따라 다른 컴포넌트 렌더링할 수 있음 <br>
                    라우팅: 다른 주소에 따라 다른 뷰를 보여주는는데 "경로에 따라 변경한다"라는 의미로 라우팅이라고 함.<br>
                    리액트 라우터의 주요 컴포넌트:
                <ul>
                    <li>BrowserRouter: 라우터 역할</li>
                    <li>Routes와 Route: 경로 매칭</li>
                    <li>Link: 경로 변경</li>
                </ul>
                이 컴포넌트를 사용하기 위해서는 React Router 라이브러리에서 따로 불러와야 한다. 다음 명령어 사용:
                <ul>import { BrowserRouter, Routes, Route, Link } from "react-router-dom";</ul>
                </p>
                <p></p>

                <h4>과제 하면서</h4>
                <ul><li>리액트 라우터 - 주소로 페이지화</li>
                <li>App.js가 루트인 경우가 많음</li>
                <li>어떤 회사는 라우팅 해주는 파일을 따로 만듬 (관심사 분리)</li>
                <li>client에서는 import from을 많이씀. {}로 테스트 할 것을 가져옴</li></ul>

            </article>


            <article>
                <h3>심화 - React State & Props</h3>
                <p>장바구니에 옷을 담고 결제 하려다 마음이 바뀌었다. 그 옷을 빼고 새 옷을 담아 결제를 했다.
                    이 때 장바구니의 상태(State)가 변했고, 결제 페이지에 변경된 장바구니의 상태를 전달(Props)해야 했다.
                </p>

                <h4>State</h4>
                <p>React에서는 state를 다루는 방법 중 하나로 useState라는 특별한 함수를 제공함
                <ul>
                    <li>import { useState } from "react";</li>
                    <li>useState를 컴포넌트 안에서 호출</li>
                    <li>const [stete 저장 변수, state 갱신 함수] = useState(상태 초기 값);</li>
                    <li>이 state 변수에 저장된 값을 쓰려면 JSX 엘리먼트 안에 직접 불러 사용하면 됨.
                    </li>
                </ul>
                </p>

                <p style="font-weight: bold;">state 갱신하기 예시</p>
                <pre><code>
                    function CheckboxExample() {
                        const [isChecked, setIsChecked] = useState(false);

                        const handleChecked = (event) => {
                            setIsChecked(event.target.checked);
                        };

                        return (
                            <div className="App">
                                <input type="checkbox" checked={isChecked} onChange="{handleChecked}" />
                                <span>{isChecked ? "Checked!!" : "Unchecked"}</span>
                            </div>
                        );
                    }
                </code></pre>
                <p>React에서는 state(상태)를 업데이트하려면 setState 함수 같은 것을 사용해야 함.<br>
                    예시에서 isChecked라는 상태가 있을 때, 이 값을 업데이트하려면 setIsChecked라는 함수를 호출야 함.<br>
                    체크박스를 클릭하면 handleChecked 함수가 호출되고, 이 함수에서 setIsChecked를 사용해 isChecked 값을 갱신. <br>
                    그러면 React가 그 새로운 값을 바탕으로 컴포넌트를 다시 렌더링하는 방식임.</p>
                <p style="font-weight: bold;">주의점<br>
                <ul>
                    <li>React 컴포넌트는 state가 변경되면 새롭게 호출되고 리렌더링 됨</li>
                    <li>React state는 상태 변경 함수 호출로 변경해야 함</li>
                </ul>
                </p>

                <h4>Props</h4>
                <p>Props 특징:
                <ul>
                    <li>부모 컴포넌트에서 자식 컴포넌트로 전달하는 값</li>
                    <li>객체 형태</li>
                    <li>읽기 전용</li>
                </ul>
                </p>

                <p>Props 사용 방법:
                <ol>
                    <li>하위 컴포넌트에 전달하고자 하는 값(data)과 속성을 정의한다</li>
                    <li>props를 이용하여 정의된 값과 속성을 전달한다</li>
                    <li>전달받은 props를 렌더링한다</li>
                </ol>
                </p>

                <p><div>e.g.글로벌하게 쓰는 컴포넌트로 감쌀 때
                <pre>
                    import { Header } from '@/components/layouts/Header'

export const AppLayout = ({ children }: { children: React.ReactNode }) => {
	return ...
                </pre>
                </div></p>

                <h4>이벤트 처리</h4>
                <p>이벤트 처리 방법은 DOM의 이벤트 처리 방식과 유사하지만 몇 가지 문법 차이가 있음
                <ul>
                    <li>React에서 이벤트는 소문자 대신 카멜 케이스를 사용</li>
                    <li>JSX를 사용해 문자열이 아닌 함수로 이벤트 처리 함수(Event handler)를 전달함
                    </li>
                </ul>
                </p>

                <h4>Controlled Component</h4>
                <p>편지봉투에 보내는 사람, 받는 사람 정보를 쓰는 것과 비슷. 변경되는 값들이 상태로 관리됨</p>

                <h4>React 데이터 흐름</h4>
                <p>단방향 데이터 흐름<br>
                    상태는 최소화 하는 것이 가장 좋음<br>
                    만약 지갑을 만ㅡ다면 유의 지갑 주와 발란스는 무조건 상태로 관리 <br>
                    다음 세 질문을 통해 어떤 데이터를 상태로 두어야 할지 판단해보자
                <ul>
                    <li>부모로부터 props를 통해 전달됩니까? > 그렇다면 state가 아님</li>
                    <li>시간이 지나도 변하지 않나요? > 그렇다면 state가 아님</li>
                    <li>컴포넌트 안의 다른 state나 props를 가지고 계산 가능한가요? > 그렇다면 state가 아님</li>
                </ul>
                </p>

                <h4>상태 위치 정하기</h4>
                <p>두 개의 서로 다른 컴포넌트가 하나의 특정 상태에 접근하고자 할 때 두 자식의 공통 부모 컴포넌트에 상태를 위치해야 함</p>

                <h4>과제 하면서</h4>
                <ul><li>npm use 16.20.2 (무조건 업뎃하지 말고 내게 필요한 버전 확인하고 사용)</li>
                    <li>시멘틱 엘리먼트: 씨멘틱 태그는 태그 자체에 의미가 있다. 해더나 푸터 처럼. </li>
                    <li>링크는 리모콘과 같다고 보면 됨</li>
                    <li>잘 모를 때 console.log 해보기</li></ul>
            </article>


            <article>
                <h3>HTTP/네트워크</h3>
                <h4>2 티어 아키텍처</h4>
                <p>클라이언트 - 서버 아키텍처; 리소스가 존재하는 곳(서버)과 리소스를 사용하는 앱을 분리시킨 것<br>
                    커피숍 손님(Client)는 리소스를 가지고 있는 점원(Server)에게 물품을 "요청" 해야 함.
                    요청에 따라 점원(Server)는 리소스를 담아 응답함. </p>
                <p>3-Tier 아키텍처: 보통 서버는 리소스를 전달해줄 뿐 저장하는 공간은 '데이터베이스' 라는 창고에 둠
                <ul>
                    <li>Java의 스프링 프레임워크</li>
                </ul>
                </p>

                <h4>HTTP</h4>
                <p>HyperText Transfer Protocol. <br>
                    웹에서 클라이언트(브라우저 등)와 서버 간에 데이터를 주고받기 위한 프로토콜<br>
                    HTTPS: HTTP에 보안이 추가된 버전. 데이터가 암호화됨</p>

                <h4>HTTP Messages</h4>
                <p>클라이언트와 서버 간의 소통을 정의하는 기본 단위; 요청과 응답 메세지로 구성됨.<br>
                    요청(Requests)과 응답(Responses)는 다음과 같은 유사한 구조를 가짐:
                <ul>
                    <li>start line: 요청이나 응답의 상태</li>
                    <li>HTTP headers</li>
                    <li>empty line</li>
                    <li>body: payload</li>
                </ul>
                Stateless: HTTP는 통신규약일 뿐 상태를 저장하지 않음. 햄버거 가게에서 내가 전 날 주문한 것을 기억 못하는 것처럼.
                </p>

                <h4>HTTP Requests</h4>
                <p style="font-style: italic;">
                    가져다 쓸 줄 알아야 하지만 암기할 필요 없고, 내용에 매몰되지 말기.
                <p style="font-weight: bold" ;>Start line</p>
                <ol>
                    <li>수행할 작업이나 방식을 설명하는 HTTP method를 나타냄.
                        <ul>
                            <li>예: GET method는 리소스를 받아야 하고, POST method는 데이터를 서버로 전송함</li>
                        </ul>
                    </li>
                    <li>요청 대상 또는 프로토콜, 포트, 도메인의 절대 경로는 요청 컨텍스트에 작성됨.
                        이 요청 형식은 HTTP method 마다 다름
                        <ul>
                            <li>origin 형식, absolute 형식, authority 형식, asterisk 형식</li>
                        </ul>
                    </li>
                    <li>HTTP 버전</li>
                </ol>

                <p style="font-weight: bold;">Headers</p>
                <ul>
                    <li>Request headers: fetch를 통해 가져올 리소스나 클라이언트 자체에 대한 자세한 정보 포함</li>
                    <li>General headers: 메시지 전체에 적용됨; body를 통해 전송되는 데이터와 관련 없음</li>
                    <li>Representation headers: body에 담긴 리소스의 정보를 포함</li>
                </ul>
                <p style="font-weight: bold;">Body</p>
                <ul>
                    <li>단일-리소스 본문(Single-resource bodies)
                        <ul>
                            <li>해더 두 개(Content-Type과 Content-Length)로 정의된 단일 파일로 구성됨</li>
                        </ul>
                    </li>
                    <li>다중-리소스 본문(Multiple-resource bodies)
                        <ul>
                            <li>여러 파트로 구성된 본문에서는 각 파트마다 다른 정보를 지님</li>
                        </ul>
                    </li>
                </ul>
                </p>

                <h4>HTTP Responses</h4>
                <p style="font-weight: bold" ;>Status line</p>
                다음 정보 포함:
                <ol>
                    <li>현재 프로토콜의 버전</li>
                    <li>상태 코드 - 요청의 결과를 나타냄</li>
                    <li>상태 텍스트 - 상태 코드에 대한 설명</li>
                </ol>
                <ul>
                    <li>예: HTTP/1.1 404 Not Found</li>
                </ul>

                <p style="font-weight: bold" ;>Headers</p>
                요청 해더와 동일한 구조

                <p style="font-weight: bold" ;>Body</p>
                <ul>
                    <li>단일-리소스 본문
                        <ul>
                            <li>길이가 알려진 단일-리소스 본문의 두 개의 해더로 정의함</li>
                            <li>길이를 모르는 단일 파일로 구성된 단일-리소스 본문은 Transfer-Encoding이 chunked로
                                설정되어 있으며, 파일은 chunk로 나뉘어 인코딩 되어 있음
                            </li>
                        </ul>
                    </li>
                    <li>다중-리소스 본문(Multiple-resource bodies)
                        <ul>
                            <li>서로 다른 정보를 담고 있는 body</li>
                        </ul>
                    </li>
                </ul>

                <h4>URL과 URI</h4>
                <p>URL: 서버가 제공되는 환경에 존재하는 파일의 위치
                <ul><span style="color: green;">:scheme: </span>
                    <span>:hosts </span>
                    <span style="color: blue;">:url-path: </span>
                    <span style="color: red">:query:</span>
                </ul>

                <ul><span style="color: green;">file://</span>
                    <span>127.0.0.1</span>
                    <span style="color: blue;">/Users/username/Desktop/</span>
                </ul>

                <ul><span style="color: green;">http://</span>
                    <span>wwww.google.com:80</span>
                    <span style="color: blue;">/search</span>
                    <span style="color: red">?q=JavaScript</span>
                </ul>
                </p>

                <ul>
                    <li>scheme: 통신 방식(프로토콜)을 결정함</li>
                    <li>hosts: 웹 서버의 이름이나 도메인, IP를 사용해 주소를 나타냄</li>
                    <li>port: 웹 서버에 접속하기 위한 통로. 예: :80</li>
                    <li>url-path: 웹 서버에서 지정한 루트 디렉토리로부터 시작해 웹 페이지, 이미지, 동영상 등이 위치한 경로와 파일명을 나타냄</li>
                    <li>query: 웹 서버에 전달하는 추가 질문</li>
                </ul>

                <p>URL: Uniform Resource Locator; 집주소나 연락처처럼 내가 있는 곳을 나타냄<br>
                    URI: uniform Resource Identifier
                <ul>
                    <li>URI는 scheme, hosts, url-path에 더해 query, fragment를 포함함</li>
                </ul>
                </p>

                <h4>IP와 포트</h4>
                <p>IP address(Internet Protocol address, IP 주소):
                    네트워크에 연결된 특정 PC의 주소를 나타내는 체계<br>
                    PORT: 그 주소에 진입할 수 있는 정해진 통로; 이미 사용 중인 포트는 중복해서 사용할 수 없음
                </p>
                <p4>IPv4: 닷(.)으로 구분된 네 덩이의 숫자로 구분된 IP 주소체계</p4>

                <h4>도메인과 DNS</h4>
                <p>
                    IP 주소가 지번 또는 도로명 주소라면, 도메인 이름은 해당 주소에 위치함 상호<br>
                    nslookup: 터미널에서 도메인 이름을 통해 IP 주소를 확인하는 명령어
                </p>
                <p>
                    DNS: 대여한 도메인 이름과 매칭된 IP 주소를 확인하는 작업을 하는 서버
                </p>

                <h4>크롬 브라우저 에러 읽기</h4>
                <p>chrome://network-errors/ 에서 에러 메세지 검색할 수 있음 </p>

                <h4>SPA를 만드는 기술: AJAX</h4>
                <p>웹페이지 컴포넌트에서 필요한 데이터가 있으면 서버로부터 비동기적으로 가져올 수 있는 방법. "방법론".
                    <br>예: 검색창에 한 글자를 입력할 때마다 해당 글자로 시작하는 단어들을 서버로부터 받아와 아래 추천 검색어로 보여주는데,
                    여기에 AJAX가 사용됨. 검색창에서는 필요한 데이터만 비동기적으로 받아와 렌더링 됨
                    <br>예: 원티드 채용 공고 목록에서 무한 스크롤이 발생할 대마다 Fetch를 통해 데이터를 가져와 업데이트 하고 렌더링 함
                </p>

                <p>AJAX의 두 가지 핵심 기술</p>
                <ul>
                    <li>Fetch:사용자가 현재 페이지에서 작업을 하는 동안 비도기적인 방식으로 필요한 데이터를 서버로부터 받을 수 있게 해줌
                    </li>
                    <li>JavaScript와 DOM: Fetch를 통해 필요한 데이터만 가져와 DOM에 적용시켜 필요한 부분만 변경</li>
                </ul>

                <p>AJAX의 장점<br>
                <ul>
                    <li>서버에서 HTML을 완성하여 보내주지 않아도 웹페이지 만들 수 있음</li>
                    <li>유저 중심 애플리케이션 개발 AJAX를 사용하면 필요한 일부분만 렌더링 하기 때문에
                        빠르고 더 많은 상호작용이 가능한 애플리케이션을 만들 수 있음
                    </li>
                    <li>더 작은 대역폭: 필요한 데이터를 텍스트 형태(JSON, XML 등)로 보내면 되서 비교적 데이터 크기가 작음</li>
                </ul>
                </p>

                <p>AJAX의 단점<br>
                <ul>
                    <li>SEO에 불리함. AJAX 방식의 웹 애플리케이션의 HTML 파이은 뼈대만 있고 데이터는 없기 때문에 사이트의 정보를 긁어가기 어려움
                    </li>
                    <li>뒤로가기 버튼 문제. AJAX에서는 이전 상태를 기억하지 않기 때문에 사용자가 의도한 대로 동작하지 않음.
                        별도로 History API를 사용해야 함.
                    </li>
                </ul>
                </p>


                <h4>SSR과 CSR</h4>
                <p><span style="font-weight: bold;">Server Side Rendering:</span>
                    웹 페이지를 서버에서 렌더링함 </p>
                <ol>
                    <li>브라우저가 서버의 URI로 GET 요청을 보내면, </li>
                    <li>서버는 정해진 웹 페이지 파일을 브라우저로 전송 </li>
                    <li>서버의 웹 페이지가 브라우저에 도착하면 완전히 렌더링 됨</li>
                </ol>

                <p><span style="font-weight: bold;">Client Side Rendering:</span>
                    웹페이지를 클라이언트에서 렌더링함</p>
                <ol>
                    <li>브라우저의 요청을 서버로 보내면 서버는 웹 페이지의 골격이 될 단일 페이지를 보냄
                        (이 때 서버는 웹 페이지와 함께 JavaScript 파일을 보냄)</li>
                    <li>클라이언트에서 웹 페이지와 함께 전달된 JavaScript 파일은 브라우저의 웹 페이지를 완전히 렌더링 된 페이지로 바꿈</li>
                    <li>데이터베이스에 저장된 데이터가 필요하면, 브라우저는 Fetch와 API를 사용해 브라우저가 요청한 경로에 따라 페이지를 다시 렌더링함</li>
                    </li>
                </ol>

                <p style="color: #ff4d94;">SSR, SCR 차이점</p>
                <ul>
                    <li>주요 차이점은 페이지가 렌더링 되는 위치. SSR은 서버에서, CSR은 클라이언트에서</li>
                    <li>CSR은 사용자가 다른 경로를 요청할 때마다 페이지를 새로고침 하지 않고 동적으로 라우팅을 관리</li>
                    <li>SSR 사용: SEO가 우선 순위인 경우, 웹 페이지의 첫 화면 렌더링이 빠르게 필요한 경우
                        (SSR이 단일 파일 용량이 적음), 웹 페이지가 사용자와 상호작용이 적은 경우; 예: 네이버 블로그
                    </li>
                    <li>CSR 사용: 사이트에 풍부한 상호작용이 있는 경우(빠른 라우팅으로 강력한 사용자 경험 제공),
                        웹 애플리케이션을 제작하는 경우(빠른 동적 렌더링 등 더 나은 사용자 경험 제공); 예: 아고다
                    </li>
                </ul>


                <h4>REST API</h4>
                <ul>
                    <li>Representational State Transfer</li>
                    <li>웹(http)의 장점을 최대한 활용할 수 있는 아키텍처로써 처음 소개됨</li>
                    <li>웹에서 사용되는 데이터나 자원을 HTTP URI로 표현하고,
                        HTTP 프로토콜을 통해 요청과 응답을 정의하는 방식</li>
                    <li>HTTP 프로토콜을 기반으로 요청과 응답에 따라 리소스를 주고받기 위해서는 알아보기 쉽고 잘 작성된 메뉴판이 필요</li>
                </ul>

                <h4>리처드슨의 REST 성숙도 모델</h4>
                <ul>
                    <li>0단계: HTTP 사용</li>
                    <li>1단계: 개별 리소스와의 통신 준수</li>
                    <li>2단계: HTTP 메소드 원칙 준수</li>
                    <li>3단계: HATEOAS 원칙 준수</li>
                </ul>
                2단계까지만 적용해도 좋은 API 디자인이라 볼 수 있고, 이런 경우를 HTTP API라고 부른다.

                <h4>REST 성숙도 모델 - 0단계</h4>
                HTTP 프로토콜 사용하면 됨<br>
                REST API를 작성하기 위한 기본 단계

                <h4>REST 성숙도 모델 -1단계</h4>
                개별 리소스와의 통신 준수<br>
                즉 모든 자원은 개별 리소스에 맞는 엔드포인트를 사용해야 하며 요청하고 받는 자원에 대한 정보를 응답으로 전달해야 한다.

                <h4>REST 성숙도 모델 - 2단계</h4>
                CRUD(Create, Read, Update, Delete)에 맞게 적절한 HTTP 메서드를 사용하는 것에 중점.
                <ul>
                    <li>예: 예약 가능한 시간 확인: 예약 가능한 시간을 조회(READ) >
                        특정 시간에 예약 생성(CREATE)
                    </li>
                    <li>조회(READ) 하기 위해 GET 메서드를 사용해 요청을 보내고,
                        이 때 GET 메서드는 body를 가지지 않기 때문에 query parameter를 사용해 필요한 리소스 전달
                        <ul>
                            <li>예약 가능한 시간 확인 요청: GET /doctors/허준/slots?date=2022-8-10 HTTP/1.1</li>
                        </ul>
                    </li>
                    <li>예약을 생성(CREATE) 하기 위해 POST 메서드를 사용해 요청을 보내고,
                        POST 요청에 대한 응답이 어떻게 반환되는지가 중요함.
                        <ul>
                            <li>특정 시간에 예약 요청: POST / slots/123 HTTP/1.1 {"patient" : "김코딩"}</li>
                            <li>요청에 대한 응답: HTTP/1.1 201 Created
                                <ul>Location: slots/123/appointment</ul>
                            </li>
                        </ul>
                        </il>
                </ul>

                <p>HTTP 메서드를 사용할 때 유의할 규칙:
                <ul>
                    <li>GET 메서드는 데이터를 변화시키지 않는 요청에 사용</li>
                    <li>POST 메서드는 요청마다 새로운 리소스 생성</li>
                    <li>PUT 메서드는 요청마다 같은 리소스 반환. (이를 멱등idempotent하다고 함)</li>
                    <li>PUT은 교체, PATCH는 수정의 용도로 사용</li>
                </ul>
                </p>

                <h4>REST 성숙도 모델 - 3단계</h4>
                HATEOAS 원칙 준수; 하이퍼미디어 컨트롤 적용; 응답에 리소스의 URL을 포함한 링크 요소를 삽입해 작성해야 함<br>

                <p>Rest 성숙도에 대해 읽을 거리: <a href="https://blog.dreamfactory.com/odata-vs-rest-what-you-need-to-know">OData
                        vs Rest</a></p>


                <h4>Open API와 API Key</h4>
                <p>정부에서 Open API 형태로 공공 데이터 제공<br>
                    Open API 검색할 수 있는 곳:
                    <a href="https://www.data.go.kr/">공공데이터 포털</a>
                    Open API 경험할 수 있는 사이트: <a href="https://openweathermap.org/">Open Weather Map</a>
                </p>
                <p>API Key: 서버의 문을 여는 열쇠<br>
                    API Key가 필요한 경우에 데이터를 요청할 때 API key를 같이 전달해야 원하는 응답을 받을 수 있음
                <ul>
                    <li>예: <a href="https://www.alchemy.com/">Alchemy(블록체인을 더 빠르게 쓰고 싶을 때)</a></li>
                </ul>
                </p>

                <h4>Postman</h4>
                <p><a href="https://www.postman.com/downloads/">Postman:</a> API 테스팅 무료로 할 수 있는 곳<br>
                <ul>
                    <li>테스트를 위해 매번 코드를 작성하는 대신 HTTP 요청을 테스트 할 수 있는 API 테스트 도구</li>
                </ul>
                </p>

            </article>


            <article>
            <h3>React 클라이언트 Ajax 요청</h3>
            <h4>State 끌어올리기</h4>
            <p>React는 데이터 흐름이 단반향으로 흐르는데 어떻게 하면 부모의 상태를 변경할까? State 끌어올리기로 해결<br>
            마치 콜백처럼 함수 자체를 props로 전달함
            <ul><li>속성: handleButtonClick</li>
                <li>값: 트윗 목록 추가 함수 addNewTweet</li></ul>
            상위 컴포넌트의 "상태를 변경하는 함수(handler)"를 하위 컴포넌트에 props로 전달하고, 
            이 함수를 하위 컴포넌트가 실행함으로써 해결 
            </p>
            <p>
                <a href="https://ko.legacy.reactjs.org/docs/lifting-state-up.html">State 끌어올리기 예제</a>
            </p>

            <h4>Side Effect</h4>
            <p>함수 내에서 어떤 구현이 함수 외부에 영향을 끼치는 경우 해당 함수는 Side Effect가 있다고 함.<br>
            Pure Function(순수 함수)란 오직 함수의 입력만이 함수의 결과에 영향을 주는 함수를 의미함<br>
            <ul><li>React의 함수 컴포넌트: props가 입력으로, JSX Element가 출력으로 나감. 
                여기에는 그 어떤Side Effect도 없으며 순수 함수로 작동함.</li></ul>
                하지만 보통 React 애플리케이션을 작성할 때에는, AJAX 요청이 필요하거나, LocalStorage 또는 타이머와 같은 React와 상관없는 API를 사용하는 경우가 발생할 수 있습니다. 이는 React의 입장에서는 전부 Side Effect입니다. React는 Side Effect를 다루기 위한 Hook인 Effect Hook을 제공합니다.
            <br>React 컴포넌트에서의 Side Effect
            <ul><li>타이머 사용</li>
            <li>데이터 가져오기</li></ul> 
            </p>
            
            <h4>Effect Hook</h4>
            <p>useEffect는 함수형 컴포넌트에서 Side Effect를 실행할 수 있게 해주는 Hook.
            <br>Hook이란 리액트 useState처럼 함수형 컴포넌트에서 상태(state)와 생명주기(lifecycle) 기능을 사용할 수 있게 해주는 함수
            <br>useEffect 예시: 
                <ul>useEffect(함수, [의존성 배열]);</ul>
                <ol><li>첫 번째 인자(함수)
                    <ul><li>Side Effect를 실행하는 함수</li>
                    <li>이 함수는 컴포넌트가 렌더링된 후 실행됨</li>
                    <li>함수 내에서 반환 하는 값은 정리</li>
                    <li>(clean-up) 함수로, 컴포넌트가 언마운트 되거나 
                        다음 렌더링 전에 실행됨</li>
                        </ul>
                        </li>
                    <li>두 번째 인자(의존성 배열)
                        <ul><li>이 배열에 포함된 값이 변결될 때만 Effect가 실행됨</li>
                        <li>배열이 비어있으면([]), Effect는 
                            컴포넌트가 마운트될 때 한 번만 실행되고, 
                            언마운트될 때 정리 함수가 실행됨
                        </li>
                        <li>배열을 생략하면 Effect는 매 렌더링마다 실행됨</li></ul>
                    </li></ol>

                    useEffect는 언제 실행되나요? (첫 번째 인자(함수)만 있을 경우)
                    <ul><li>컴포넌트 생성 후 처음 화면에 렌더링(표시)</li>
                    <li>컴포넌트에 새로운 props가 전달되며 렌더링</li>
                    <li>컴포넌트에 상태가 바뀌며 렌더링 </li></ul>
                    즉 매번 새롭게 컴포넌트가 렌더링 될 때 Effect Hook이 실행됨
                    </p>
            <p style="font-weight: bold;">Hook을 쓸 때 주의할 점</p>
            <ul><li>최상위에서만 Hook을 호출한다</li>
            <li>React 함수 내에서 Hook을 호출한다</li></ul>
            <br>
            참고 자료: <a href="https://ko.legacy.reactjs.org/docs/hooks-rules.html#only-call-hooks-at-the-top-level">Hook의 규칙 공식 문서</a>

            <h4>Effect Hook 조건부 실행</h4>
            조건부 effect 발생 (dependency array)
            <ul>useEffect(함수, [의존성 배열]);</ul>
            useEffect의 두 번째 인자는 배열이고, 이 배열은 조건을 담고 있다. 
            <br>여기서 조건은 어떤 값의 변경이 일어날 때를 의미함. 
            따라서 해당 배열엔 어떤 값의 목록이 들어간다. 이 배열을 특별히 종속성 배열이로 부른다. 
            <br>
            예시: 명언 찾는 웹사이트 <br>
            세 상태 존재: 
            <ul><li>명언 목록(proverbs)</li>
            <li>필터링할 문자열(effect)</li>
            <li>카운트(count)›</li></ul>
            이 예제어서 filter(사용자가 입력하는 문자열) 값이 변경될 때마다 
            useEffect 훅이 실행됨. 즉 filter 값이 바뀌면 명언 목록을 해당 filter에 맞게 보여줄 수 있게 됨. 
            <br>
            <p style="font-weight: bold;">단 한 번만 실행되는 Effect 함수</p>
            만약 종속성 목록에 아무 종속성도 없다면 어떻게 될까? 
            <ol><li>useEffect(함수, []) - 빈 배열 넣기 
                <ul><li>컴포넌트가 처음 생성될 때만 effect 함수가 실행될 것. 
                    예를 들어 처음 단 한 번, 외부 API를 통해 리소스를 받아오고 
                    더 이상 API 호출이 필요하지 않을 때 사용할 수 있음 
                </li></ul>
            </li>
            <li>useEffect(함수) - 아무것도 넣지 않기 (기본 형태)
                <ul><li>useEffect는 컴포넌트가 처음 생성되거나 props가 업데이트 되거나 
                    상태가 업데이트 될 때 effect 함수가 실행됨 
                </li></ul>
            </li></ol> 
            
            <h4>컴포넌트 내에서의 Ajax 요청</h4>
            <p>목록 내 필링을 구현하기 위한 두 가 접근은?</p>
            <ol><li>컴포넌트 내에서 필터링
                <ul><li>전체 목록 데이터를 불러오고 목록을 검색어로 필터링</li>
                <li>예: 처음 단 한 번 외부 API로부터 명언 목록을 받아와 필터 함수 이용</li></ul>
            </li>
            <li>컴포넌트 외부에서 필터링
                <ul><li>컴포넌트 외부로 API 요청할 때 필터링한 결과를 받아오는 방법 (보통, 서버에 매번 검색어와 함께 요청하는 경우)
                </li>
                <li>검색어가 바뀔 때마다 외부 API 호출</li></ul>
            </li></ol>
            <br> 
            <p>seEffect를 써서 AJAX 요청을 보내는 코드를 로컬 파일에서 가져오는 것과 비교해보세요. </p>
            <pre><code>
                useEffect(() => {
                    fetch(`http://서버주소/proverbs?q=${filter}`)
                      .then(resp => resp.json())
                      .then(result => {
                        setProverbs(result);});}, [filter]);
            </code></pre>
            반면 컴포넌트 내부에서 필터일 할 때는 useEffect 다음과 같이 쓸 수 있다: 
            <pre><code>
                import { getProverbs } from "./storageUtil"; 
                useEffect(() => {
                    console.log("Effect 함수 실행: 컴포넌트가 마운트되었습니다.");
                    const result = getProverbs();
                    setProverbs(result);}, []);
            </code></pre>
            <br>
            
            <p>AJAX 요청이 매우 느릴 경우에는? 
            <br>외부 API 접속이 느릴 경우를 고려해 로딩 화면(loading indicator)의 구현은 필수</p>
            <br>Loading indicator의 구현은 어떻게 처리할 수 있을까? 상태처리 필요 
            <pre><code>
                const [isLoading, setIsLoading] = useState(true);
                    // 생략, LoadingIndicator 컴포넌트는 별도로 구현했음을 가정합니다
                return {isLoading ? (꺽쇠)LoadingIndocator /> : (꺽쇠)div로딩 완료 화면</ div>}
                </code></pre>
            <br>fetch 요청 전후로 setIsLoading을 설정해 보다 나은 UX 구현할 수 있음.
            <pre><code>
                setIsloading(true);
            </code></pre>

            
            
        </article>


        </section>

        <section id="contact">
            <h2>문의</h2>
            <p>
                이메일: <a href="mailto:chatjip9@gmail.com">chatjip9@gmail.com</a>
            </p>


            <p style="color: #46922f; font-style: italic;">블록체인에 대해 함께 공부하거나 이야기하고 싶으신 분은 이메일 주소를 남겨주세요.
            <form>
                <input type="email" placeholder="이메일을 입력하세요" required>
                <button type="submit" onclick="showMessage()"
                    style="background-color: #ff4d94; border: none; color: darkblue;">제출</button>
            </form>
            </p>

            <script>
                function showMessage() {
                    alert("감사합니다");
                }
            </script>
        </section>
    </main>



    <footer>
        <p>&copy; 2025 나의 블록체인 일지. All rights reserved.</p>
    </footer>

</body>

</html>